<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人写作格式</title>
    <url>/2024/01/02/%E4%B8%AA%E4%BA%BA%E5%86%99%E4%BD%9C%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e6783afcfe0cdb8351bf3c983d63f98836fcfe8812c9ceca00cf9c027221a423">2f5da2e463e91b2a7d8c0894f553bf60538f0c566698ea1b65aed2c5d8d188ba627e40e3e40d8ca2e1001ebcf07c634e328c846fa12e318681590067aa9eaf934546e21fe98cdf6330e1f92ba56b05fba3dd9d2a9b2f7aa9748834fe153c6a97622ac016c388ba613a82d06ec206fd79a2900447d99a258672cd7a3cd5de5c9a722c32f55bb9d54c583124822af5b24ff2724c421e0b22dc74dff4f7b9259d305fe378f8240d6206db02b71ae109991140755b3201f7e7a5bb70e17e019dff2bd85c923d15b5e71639bd5de4c8a5a00fc637aaa9f614f64583ab82a61c245d6be437262928ba4132bba1463e413aec5b74a479233eee7ac2e3c1ede5a1c323b548a418c81554751b724f94846a99de04c68e747c6627eda3bd353fd7c40e5fe0c45faf471db27a1359447939e49e0d9dbd0a760c361cffd2bdfbe3ca835146d121e70f9d46045d62d321f0b7475615bb85f2310f9fc5a0e23d15798a0486a05b7c35568734f37f47bbd5b75ce4ddf3750017c8fe94bb0a8960a585d6767a6452179f38baca0d1c686d82ed3443af7735253d0cae3d6da6a48df7b1f606f4d8b29a0f74c9ca6efb3978f4703b7cb790f59110ca6843084cdb37e8c6403adb5b7bc7723393c4a4fa21a933440750c45ab4d6d87dfed2852021ded3554b5e09c58480fdde79bcd462683afb632c16a829a0b756999d1e7dda9369d7eb027cbbe744e6ae45a9802d931c184cf0c1da0a114232e385437126c1a823c52fff7957f6550ef0ae8332502a6b6538e2b054f6bf37bdd31242d880ea184a0c839acb3dcb109b76cc8700c933890e7aadecf70cf4a5d52bc4bc73c281d571a7e02d46ee9a7b388f88ea00e16380440404f03e8c363e0694c4f697db426cc84dae0ef9fb5967c9a6b5117b15fb43561e3601dd3e9e3729779218f1e9b128b8e879e92d6d54b3bfd4de52825196e96065ae0a9f9c714f79ca6c1bdefd501ef94d33f0c2e224d81cd2cdd02224171c75338583d93f8998af35fb7e6438b78313388c65e13086d1758716a1b0ec011bacb8456e676314e2716d130bfd68155d3d81ea1de955a57b9dd220fba85d0b2f98b72df72d51f5aa1300dc910a650955ab6a70cbe0b450bc9fca3a5bdf8ad920c02df820da9735ac07ec28a3aec217f9b22446b6c7af3363112b7bd473d6260adffb85f623d6ef8a97f4b7442a531767053fa28f6eb6d0b2079c325ac620b6ab6be81f82facd759606d5346c1337c2c32a60feaae5f0d5bc43650e25a75d80e8ad276e3dba0de047efbccc1f3051fe3ef2d1a34d50c40aec3489ba8b400c4baf520c092c519c6cca14cd150d96c7766f63afb8757ad829e88b4400aa1f72ea8bbdef800c005bf7a2f846ac5caa49c0e6085854f41ea00742263fd1c36db470d73d8d3f68ea06b046a56c985e9d18fff2bf3122b09f7ca9ed9405691e9c9e54677a29ab08a67fc9c760451ce2c7c11d914f02b5472acfe092ad30941e7058521afe5719957a302bb6b656bcaf42ed7ca4e36ec15aa5de31482177dfc14370e4e8c69cb7395e1ba02e7934e0dd90e41d39ededa2e21d0bc9ce3f51f1672e309c31d99c81e91ca2af9837283ddd4e95f4aeb016d42013d7ebea713aea31de4ab8b33b1f8477dd64e57585f0d5ba9dbd5e3d901e420bf7933905ebb96050f9954453cbdec3d49837eb4098757e32442d3aa0b6ca7d8d186f89ec9a9617c61db4b42d0757d255afdee7281c61f96976ca129c4264774f9ff0a3344651b94351c28a76afbc64c357b1be0a598e65a33497fd9db50263caa94f6913068722f63f471373c1dc20d27634f4fae385a4f5ad82eb1c0c3649e32450b0ea76cfe042d8a55dc88c76803f1eac8bf2d70b67bf1c5d1e587e90109ceb0f23c0c27571d2aa6241fdc882f5e2a834bd0bb2e2ecb6919db78429d48835bd270f765a228283c7f349f2cebfb671e253d3e4b8016fb91dcfc8025e14174b0fc4df4acf83ef11952fe071469cf9f4311ea6d3ebcf6fceadb713ed772cd795467e64762ab79a3b429148fafe00e17c7ac6f56095d9c5d526fe5abc3a1be28fb96386215ecff50f9fda6ba1d975d8f4dc6eafd6976debe7c4a10480e4841933fd4e63e7c3e8b825e5f60136ab6151b4d4e7090d9f2face9435f9fd6063cca14d85b6a1704d525d40abb667e89826ecffc7fa4c381738668827d43c9bce10e12f8f3dfe041bb5a9424ce53855c0638b273ace220db594aeb9c52f162abb6de227b357019bcb416e24cfcfe0d3cf95703851c0473480d42b3ea3db3ee3b4e15dfc37067e7a9cdbf970d79ebdc72c293272531ab16b63be2fb42bfffd6aca066e5b1c55e6c9e87970cff5c6817fc421fbc88d3b0489be0ce4c909cdeac596dcfa89352f7f02c12ef0d4ee7f894f6fbae1d1f164972ec11c8fb98b8bed0ec8085ff2a4583eea46e0b305b85c55361101952087346ac16f23312ade534c31c4b7759917f868e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2024/01/01/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="这是个测试文章"><a class="markdownIt-Anchor" href="#这是个测试文章"></a> 这是个测试文章</h1>
<p>大家可以自由评论。。。</p>
<hr />
]]></content>
  </entry>
  <entry>
    <title>Mysql学习笔记</title>
    <url>/2024/01/03/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="mysql个人笔记"><a class="markdownIt-Anchor" href="#mysql个人笔记"></a> MySQL个人笔记</h1>
<h2 id="一-数据库概述"><a class="markdownIt-Anchor" href="#一-数据库概述"></a> 一、数据库概述</h2>
<h3 id="1为什么使用数据库"><a class="markdownIt-Anchor" href="#1为什么使用数据库"></a> 1.为什么使用数据库</h3>
<ul>
<li>数据持久化</li>
</ul>
<h3 id="2数据库与数据库管理系统"><a class="markdownIt-Anchor" href="#2数据库与数据库管理系统"></a> 2.数据库与数据库管理系统</h3>
<h4 id="21数据库的相关概念"><a class="markdownIt-Anchor" href="#21数据库的相关概念"></a> 2.1数据库的相关概念</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DB：数据库（Database）</span><br><span class="line">	即存储数据的仓库，其本质是一个文件系统，它保存了一个系列有组织的数据。</span><br><span class="line">DBMS：数据库管理系统（Database Managment System）</span><br><span class="line">	是一种操纵和数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</span><br><span class="line">SQL：结构化查询语言（Structured Query Language）</span><br><span class="line">	专门用来与数据库通信的语言</span><br></pre></td></tr></table></figure>
<h4 id="22数据库与数据库管理系统的关系"><a class="markdownIt-Anchor" href="#22数据库与数据库管理系统的关系"></a> 2.2数据库与数据库管理系统的关系</h4>
<p>数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存 应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_08-45-48.png"
                        alt="" 
                 ></p>
<h3 id="3rdbms与非rdbms"><a class="markdownIt-Anchor" href="#3rdbms与非rdbms"></a> 3.RDBMS与非RDBMS</h3>
<h4 id="31关系型数据库rdbms"><a class="markdownIt-Anchor" href="#31关系型数据库rdbms"></a> 3.1关系型数据库（RDBMS）</h4>
<h5 id="311实质"><a class="markdownIt-Anchor" href="#311实质"></a> 3.1.1实质</h5>
<ul>
<li>这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的 二元关系 （即二维表格形式）。</li>
<li>关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。</li>
<li>SQL 就是关系型数据库的查询语言。</li>
</ul>
<h5 id="312优势"><a class="markdownIt-Anchor" href="#312优势"></a> 3.1.2优势</h5>
<ul>
<li><strong>复杂查询</strong>：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询</li>
<li><strong>事务支持</strong>：使得对于安全性能很高的数据访问要求得以实现</li>
</ul>
<h4 id="32非关系型数据库非rdbms"><a class="markdownIt-Anchor" href="#32非关系型数据库非rdbms"></a> 3.2非关系型数据库（非RDBMS）</h4>
<h5 id="321介绍"><a class="markdownIt-Anchor" href="#321介绍"></a> 3.2.1介绍</h5>
<p><strong>非关系型数据库</strong>，可以看成传统关系型数据库的功能<em>阉割版</em>，基于键值对存储数据，不许经过SQL层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。</p>
<h5 id="321常见非关系型数据库"><a class="markdownIt-Anchor" href="#321常见非关系型数据库"></a> 3.2.1常见非关系型数据库</h5>
<h6 id="键值对数据库"><a class="markdownIt-Anchor" href="#键值对数据库"></a> 键值对数据库</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键值对数据库典型应用场景是作为内存缓存。Redis</span><br></pre></td></tr></table></figure>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-01-08.png"
                         style="zoom:50%;" 
                 >
<h6 id="文档型数据库"><a class="markdownIt-Anchor" href="#文档型数据库"></a> 文档型数据库</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，</span><br><span class="line">一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB</span><br><span class="line">是最流行的文档型数据库。此外，还有CouchDB等。</span><br></pre></td></tr></table></figure>
<h6 id="搜索引擎数据库"><a class="markdownIt-Anchor" href="#搜索引擎数据库"></a> 搜索引擎数据库</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在</span><br><span class="line">搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检</span><br><span class="line">索的时候才能保证性能最优。核心原理是“倒排索引”。</span><br><span class="line">典型产品：Solr、Elasticsearch、Splunk 等。</span><br></pre></td></tr></table></figure>
<h6 id="列式数据库"><a class="markdownIt-Anchor" href="#列式数据库"></a> 列式数据库</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储</span><br><span class="line">（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的</span><br><span class="line">I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</span><br></pre></td></tr></table></figure>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-03-43.png"
                         style="zoom:50%;" 
                 >
<h6 id="图形数据库"><a class="markdownIt-Anchor" href="#图形数据库"></a> 图形数据库</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）</span><br><span class="line">之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社</span><br><span class="line">交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：</span><br><span class="line">Neo4J、InfoGrid等。</span><br></pre></td></tr></table></figure>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-04-25.png"
                         style="zoom:50%;" 
                 >
<h3 id="4关系型数据库设计规则"><a class="markdownIt-Anchor" href="#4关系型数据库设计规则"></a> 4.关系型数据库设计规则</h3>
<ul>
<li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。<strong>表名具有唯一性</strong>。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中“类”的设计。</li>
</ul>
<h4 id="41表-记录-字段"><a class="markdownIt-Anchor" href="#41表-记录-字段"></a> 4.1表、记录、字段</h4>
<ul>
<li>E-R（entity-relationship，实体-联系）模型中有三个主要概念：实体类、属性、联系集。</li>
<li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也成为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也成为一个字段（field）。</li>
</ul>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-13-09.png"
                         style="zoom:50%;" 
                 >
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORM思想 (Object Relational Mapping)体现：</span><br><span class="line">数据库中的一个表 &lt;---&gt; Java或Python中的一个类</span><br><span class="line">表中的一条数据 &lt;---&gt; 类中的一个对象（或实体）</span><br><span class="line">表中的一个列 &lt;----&gt; 类中的一个字段、属性(field)</span><br></pre></td></tr></table></figure>
<h4 id="42表的关联关系"><a class="markdownIt-Anchor" href="#42表的关联关系"></a> 4.2表的关联关系</h4>
<ul>
<li>标语便之间的数据记录有关系（relactionship）。现实世界中的各种实体之间的各种联系均用关系模型来表示。</li>
<li>四种关联关系：一对一关联、一对多关联、多对一关联、多对多关联、自我引用</li>
</ul>
<h5 id="421一对一关联"><a class="markdownIt-Anchor" href="#421一对一关联"></a> 4.2.1一对一关联</h5>
<ul>
<li>在实际开发中应用不多，因为一对一可以创建成一张表。</li>
<li>举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急 联系人、…
<ul>
<li><strong>考虑IO效率拆分成两个一对一的关联表</strong></li>
<li>基础信息表（常用信息）</li>
<li>档案信息表（不常用信息）</li>
</ul>
</li>
<li>两种建表原则：
<ul>
<li>外键唯一：主表的主键和从表的外键（唯一），形成外键关系，外键唯一。</li>
<li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li>
</ul>
</li>
</ul>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-23-58.png"
                         style="zoom:50%;" 
                 >
<h5 id="422一对多关系"><a class="markdownIt-Anchor" href="#422一对多关系"></a> 4.2.2一对多关系</h5>
<ul>
<li>一对多建表原则：在从表（多方）创建一个字段，字段作为外键只想主表（一方）的主键</li>
</ul>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-26-44.png"
                         style="zoom:50%;" 
                 >
<h5 id="423多对多"><a class="markdownIt-Anchor" href="#423多对多"></a> 4.2.3多对多</h5>
<blockquote>
<p>要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-29-39.png"
                         style="zoom:50%;" 
                 >
<p>例如：学生-课程、产品-订单、用户-角色</p>
<h5 id="424自我引用"><a class="markdownIt-Anchor" href="#424自我引用"></a> 4.2.4自我引用</h5>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-31-04.png"
                         style="zoom:50%;" 
                 >
<h2 id="二-mysql环境搭建"><a class="markdownIt-Anchor" href="#二-mysql环境搭建"></a> 二、MySQL环境搭建</h2>
<h3 id="环境搭建常见问题"><a class="markdownIt-Anchor" href="#环境搭建常见问题"></a> 环境搭建常见问题</h3>
<h4 id="1如何正确的卸载mysql"><a class="markdownIt-Anchor" href="#1如何正确的卸载mysql"></a> 1.如何正确的卸载MySQL</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤一：停止Mysql服务</span><br><span class="line">步骤二：软件卸载（通过控制面板、第三方软件）</span><br><span class="line">步骤四：清理注册表（选）（regedit）</span><br><span class="line">步骤五：删除环境变量</span><br></pre></td></tr></table></figure>
<h4 id="2shell中mysql-version无法使用"><a class="markdownIt-Anchor" href="#2shell中mysql-version无法使用"></a> 2.shell中mysql --version无法使用</h4>
<p>未设置环境变量</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_09-39-45.png"
                        alt="" 
                 ></p>
<h4 id="3shell中登录方式不正确"><a class="markdownIt-Anchor" href="#3shell中登录方式不正确"></a> 3.shell中登录方式不正确</h4>
<ul>
<li>格式（-p与密码之间不能有空格）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -P 端口号 -u 用户名 -p密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3306 -u root -pabc123 # 这里我设置的root用户的密码是abc123</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4mysql5版本中文信息插入不成功"><a class="markdownIt-Anchor" href="#4mysql5版本中文信息插入不成功"></a> 4.mysql5版本中文信息插入不成功</h4>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values(1,&#x27;张三&#x27;);</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;name&#x27; at</span><br><span class="line">row 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是字符集问题</p>
<p>解决方式1：重新创建数据库并设置utf-8字符集、创建表并设置字符集utf-8</p>
<p>解决方式2（永久解决）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1：查看编码命令</span><br><span class="line">show variables like &#x27;character_%&#x27;;</span><br><span class="line">show variables like &#x27;collation_%&#x27;;</span><br><span class="line"></span><br><span class="line">2：修改没有事情了、的数据目录下的my.ini配置文件</span><br><span class="line">default-character-set=utf8 #默认字符集</span><br><span class="line">[mysqld] # 大概在76行左右，在其下添加</span><br><span class="line">...</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">3：重启服务</span><br><span class="line">4：查看编码命令</span><br><span class="line">show variables like &#x27;character_%&#x27;;</span><br><span class="line">show variables like &#x27;collation_%&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5mysql8版本图形化界面连接不成功错误代码2058"><a class="markdownIt-Anchor" href="#5mysql8版本图形化界面连接不成功错误代码2058"></a> 5.mysql8版本图形化界面连接不成功（错误代码2058）</h4>
<p>解决方式1：升级图形化操作界面以适配8版本</p>
<p>解决方式2：用命令行登录MySQL数据库之后，执行如下命令修改用户密码加密规则并更新用 户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为 “123456”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用mysql数据库</span><br><span class="line">USE mysql;</span><br><span class="line">#修改&#x27;root&#x27;@&#x27;localhost&#x27;用户的密码规则和密码</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;abc123&#x27;;</span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三-基本的select语句"><a class="markdownIt-Anchor" href="#三-基本的select语句"></a> 三、基本的SELECT语句</h2>
<h3 id="1sql概述"><a class="markdownIt-Anchor" href="#1sql概述"></a> 1.SQL概述</h3>
<h4 id="11sql分类"><a class="markdownIt-Anchor" href="#11sql分类"></a> 1.1SQL分类</h4>
<ul>
<li>DDL（Data Definition Languages、数据定义语言），这些语言定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构
<ul>
<li>主要i的语句关键字包括CREATE、DROP、ALTER等。</li>
</ul>
</li>
<li>DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。
<ul>
<li>主要的语句关键字包括 INSERT、DELETE、UPDATE、SELECT等。</li>
<li>SELECT是SQL语言的基础，最为重要。</li>
</ul>
</li>
<li>DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。
<ul>
<li>主要的语句关键字包括 GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为查询语句使用的非常的频繁，所以很多人把查询语句但拎出来一类：DQL（数据查询语言）。还有单独将 COMMIT、ROLLBACK取出来称为TCL（Transaction Control Language，事务控制语言）。</p>
</blockquote>
<h3 id="2sql语言的规则与规范"><a class="markdownIt-Anchor" href="#2sql语言的规则与规范"></a> 2.SQL语言的规则与规范</h3>
<ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>每条命令以 ; 或 \g 或 \G 结束</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号
<ul>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ '）表示</li>
<li>列的别名，尽量使用双引号（&quot; &quot;），而且不建议省略as</li>
</ul>
</li>
</ul>
<h4 id="22sql大小写规范建议遵守"><a class="markdownIt-Anchor" href="#22sql大小写规范建议遵守"></a> 2.2SQL大小写规范（建议遵守）</h4>
<ul>
<li>MySQL在Windows环境下是大小写不敏感的</li>
<li>MySQL在Linux环境下是大小写敏感的
<ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的</li>
</ul>
</li>
<li>推荐采用统一的书法规范：
<ul>
<li>数据库名、表名、表别名、字段名、字段别名等都大小写</li>
<li>SQL关键字、函数名、绑定变量等都大小写</li>
</ul>
</li>
</ul>
<h4 id="23注释"><a class="markdownIt-Anchor" href="#23注释"></a> 2.3注释</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：-- 注释文字(--后面必须包含一个空格。)</span><br><span class="line">多行注释：/* 注释文字 */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="25数据导入指令"><a class="markdownIt-Anchor" href="#25数据导入指令"></a> 2.5数据导入指令</h4>
<p>在命令行客户端登录mysql，使用source指令导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; source d:\mysqldb.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者使用Navicat等图形化控制界面进行导入</p>
<h3 id="3基本的select语句"><a class="markdownIt-Anchor" href="#3基本的select语句"></a> 3.基本的SELECT语句</h3>
<h4 id="31selectfrom"><a class="markdownIt-Anchor" href="#31selectfrom"></a> 3.1SELECT…FROM</h4>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT		标识选择哪些列</span><br><span class="line">FROM		标识从哪个表中选择</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>选择全部列：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	*</span><br><span class="line">FROM departments;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节 省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通 配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。 在生产环境下，不推荐你直接使用 SELECT * 进行查询。</p>
</blockquote>
<ul>
<li>选择特定的列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,location_id</span><br><span class="line">FROM departments;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="32列的别名"><a class="markdownIt-Anchor" href="#32列的别名"></a> 3.2列的别名</h4>
<ul>
<li>重命名一个列</li>
<li>便于计算</li>
<li>紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。</li>
<li>AS可以省略</li>
<li>列的别名智能在ORDER BY中使用，不能在WHERE中使用</li>
<li>别名要简短，见名知意</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select employee_id AS &quot;id&quot;</span><br><span class="line">from employees</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="33去除重复行"><a class="markdownIt-Anchor" href="#33去除重复行"></a> 3.3去除重复行</h4>
<p>默认情况下，查询会返回全部行，包括重复行。</p>
<p>在SELECT语句中使用关键字DISTINCT去除重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id,salary</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>DISTINCT其实是对后面所有列名的组合进行去重，你能看带最后的结果是74个部门id不同，都有salary这个属性值，如果你想要看都有哪些不同的部门（department_id），只需要写DISTINCT department_id即可，后面不需要再加其他的列名了。</p>
<h4 id="34空值与运算"><a class="markdownIt-Anchor" href="#34空值与运算"></a> 3.4空值与运算</h4>
<ul>
<li>所有运算符或列值遇到null值，运算的结果都为null</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary,commission_pct,</span><br><span class="line">12 * salary * (1 + commission_pct) &quot;annual_sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：在MySQL里面，空值不等于空字符串。一个空字符串的长度是0，而一个空值的长度是空。而且在MySQL里面，空值是占用空间的。</p>
<p>解决方案1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary,commission_pct,</span><br><span class="line">12 * salary * (1 + IFNULL(commission_pct,0)) &quot;annual_sal&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="35着重号"><a class="markdownIt-Anchor" href="#35着重号"></a> 3.5着重号</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `order`;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需求：我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个 字段固定值为“尚硅谷”，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;尚硅谷&#x27; as &quot;corporation&quot;, last_name FROM employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4显示表结构"><a class="markdownIt-Anchor" href="#4显示表结构"></a> 4.显示表结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE employees;</span><br><span class="line">或</span><br><span class="line">DESC employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，各个字段的含义分别解释如下：</p>
<ul>
<li>Field：表示字段名称。</li>
<li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li>
<li>Null：表示该列是否可以存储NULL值。</li>
<li>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一 部分；MUL表示在列中某个给定值允许出现多次。</li>
<li>Default：表示该列是否有默认值，如果有，那么值是多少。</li>
<li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li>
</ul>
<h3 id="5过滤数据"><a class="markdownIt-Anchor" href="#5过滤数据"></a> 5.过滤数据</h3>
<ul>
<li>背景：</li>
</ul>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_17-29-14.png"
                         style="zoom:50%;" 
                 >
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1,字段2</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 过滤条件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用WHERE子句，将不满足条件的行过滤掉</li>
<li>WHERE子句紧随FROM子句</li>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 90 ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-04_17-31-02.png"
                         style="zoom:50%;" 
                 >
<h2 id="四-运算符"><a class="markdownIt-Anchor" href="#四-运算符"></a> 四、运算符</h2>
<h3 id="1算术运算符"><a class="markdownIt-Anchor" href="#1算术运算符"></a> 1.算术运算符</h3>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-05_10-01-14.png"
                         style="zoom:50%;" 
                 >
<h4 id="11加法与减法运算符"><a class="markdownIt-Anchor" href="#11加法与减法运算符"></a> 1.1加法与减法运算符</h4>
<blockquote>
<ul>
<li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li>
<li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li>
<li>加法和减法的优先级相同，进行先加厚健操作与先减后加操作的结果是一样的；</li>
<li>在Java中，+的左右两边如果有字符串，那么便视字符串的拼接，但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转换失败，就按照0计算。（MySQL中字符串拼接要使用字符串函数CONCAT（）实现）</li>
</ul>
</blockquote>
<h4 id="12乘法与除法运算符"><a class="markdownIt-Anchor" href="#12乘法与除法运算符"></a> 1.2乘法与除法运算符</h4>
<blockquote>
<ul>
<li>一个数乘以整数1和除以整数1后仍得原数；</li>
<li>一个属成以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li>
<li>一个数除以整数后，不管是否除尽，结果都为一个浮点型</li>
<li>一个属除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li>
<li>乘法和除法得优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li>
<li>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL</li>
</ul>
</blockquote>
<h4 id="13求模求余运算符"><a class="markdownIt-Anchor" href="#13求模求余运算符"></a> 1.3求模（求余）运算符</h4>
<h3 id="2比较运算符"><a class="markdownIt-Anchor" href="#2比较运算符"></a> 2.比较运算符</h3>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-05_10-24-50.png"
                         style="zoom:50%;" 
                 >
<h4 id="21等号运算符"><a class="markdownIt-Anchor" href="#21等号运算符"></a> 2.1等号运算符</h4>
<ul>
<li>等号运算符（=）判断等号两边得值、字符串或者表达式是否相等，如果相等则返回1，不相等则返回0.</li>
<li>在使用等号运算时，遵循如下规则：
<ul>
<li>如果等号两边的值、字符串或者表达式都为字符串，则MySQL会按照字符串进行比较，其比较得时每个字符串中的ANSI编码是否相等。</li>
<li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li>
<li>如果等号两边的值是一个正式，另一个是字符串，则会MySQL会将字符串转化为数字进行比较。</li>
<li>如果等号两边的值、字符串或表达式中有一个为NULL，则比价结果为NUll</li>
</ul>
</li>
<li>对比：SQL中赋值符号使用:  =</li>
</ul>
<h4 id="22安全等于号运算符"><a class="markdownIt-Anchor" href="#22安全等于号运算符"></a> 2.2安全等于号运算符</h4>
<ul>
<li>主要用于NULL值得比较</li>
</ul>
<h4 id="23不等于运算符"><a class="markdownIt-Anchor" href="#23不等于运算符"></a> 2.3不等于运算符</h4>
<ul>
<li>不等于运算符（&lt;&gt;和!=）用于判断两边得数字、字符串或者表达式得值是否相等，如果不相等则返回1，相等则返回0.不等于运算符不能判断NULL值。如果两边得值有任意一个为NULL，或两边都为NULL，则结果为NULL。</li>
</ul>
<h4 id="非符号型运算符"><a class="markdownIt-Anchor" href="#非符号型运算符"></a> 非符号型运算符</h4>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-05_10-44-52.png"
                         style="zoom:50%;" 
                 >
<h4 id="24空运算符"><a class="markdownIt-Anchor" href="#24空运算符"></a> 2.4空运算符</h4>
<ul>
<li>判断一个值是否为NULL，如果为NULL则返回1，否则返回0</li>
</ul>
<h4 id="25非空运算符"><a class="markdownIt-Anchor" href="#25非空运算符"></a> 2.5非空运算符</h4>
<ul>
<li>判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0</li>
</ul>
<h4 id="26最小值运算符"><a class="markdownIt-Anchor" href="#26最小值运算符"></a> 2.6最小值运算符</h4>
<ul>
<li>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有 两个或多个参数的情况下，返回最小值。</li>
</ul>
<h4 id="27最大值运算符"><a class="markdownIt-Anchor" href="#27最大值运算符"></a> 2.7最大值运算符</h4>
<ul>
<li>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有 两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</li>
</ul>
<h4 id="28between-and运算符"><a class="markdownIt-Anchor" href="#28between-and运算符"></a> 2.8BETWEEN AND运算符</h4>
<ul>
<li>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</li>
</ul>
<h4 id="29in运算符"><a class="markdownIt-Anchor" href="#29in运算符"></a> 2.9IN运算符</h4>
<ul>
<li>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给 定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</li>
</ul>
<h4 id="210not-in运算符"><a class="markdownIt-Anchor" href="#210not-in运算符"></a> 2.10NOT IN运算符</h4>
<ul>
<li>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一 个值，则返回1，否则返回0。</li>
</ul>
<h4 id="211like运算符"><a class="markdownIt-Anchor" href="#211like运算符"></a> 2.11LIKE运算符</h4>
<ul>
<li>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL</li>
</ul>
<h3 id="3逻辑运算符"><a class="markdownIt-Anchor" href="#3逻辑运算符"></a> 3.逻辑运算符</h3>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-05_11-13-59.png"
                         style="zoom:50%;" 
                 >
<h4 id="31逻辑非运算符"><a class="markdownIt-Anchor" href="#31逻辑非运算符"></a> 3.1逻辑非运算符</h4>
<ul>
<li>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0； 当给定的值为NULL时，返回NULL。</li>
</ul>
<h4 id="32逻辑与运算符"><a class="markdownIt-Anchor" href="#32逻辑与运算符"></a> 3.2逻辑与运算符</h4>
<ul>
<li>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回 1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</li>
</ul>
<h4 id="33逻辑或运算符"><a class="markdownIt-Anchor" href="#33逻辑或运算符"></a> 3.3逻辑或运算符</h4>
<ul>
<li>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返 回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为 NULL时，返回NULL。</li>
</ul>
<blockquote>
<p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先 对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
</blockquote>
<h3 id="4位运算符了解"><a class="markdownIt-Anchor" href="#4位运算符了解"></a> 4.位运算符（了解）</h3>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-05_11-16-22.png"
                         style="zoom:50%;" 
                 >
<h4 id="41按位与运算符"><a class="markdownIt-Anchor" href="#41按位与运算符"></a> 4.1按位与运算符</h4>
<ul>
<li>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二 进制位的数值都为1时，则该位返回1，否则返回0。</li>
</ul>
<h4 id="42按位或运算符"><a class="markdownIt-Anchor" href="#42按位或运算符"></a> 4.2按位或运算符</h4>
<ul>
<li>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的 二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</li>
</ul>
<h4 id="43按位取反运算符"><a class="markdownIt-Anchor" href="#43按位取反运算符"></a> 4.3按位取反运算符</h4>
<ul>
<li>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变 为1。</li>
</ul>
<h4 id="44按位右移运算符"><a class="markdownIt-Anchor" href="#44按位右移运算符"></a> 4.4按位右移运算符</h4>
<ul>
<li>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的 位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</li>
</ul>
<h4 id="45按位左移运算符"><a class="markdownIt-Anchor" href="#45按位左移运算符"></a> 4.5按位左移运算符</h4>
<ul>
<li>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的 位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</li>
</ul>
<h3 id="拓展使用正则表达式查询"><a class="markdownIt-Anchor" href="#拓展使用正则表达式查询"></a> 拓展：使用正则表达式查询</h3>
<p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合 要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户 输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常 复杂的查询。</p>
<p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配 列表。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-05_11-20-09.png"
                        alt="" 
                 ></p>
<h4 id="1查询以特定字符或字符串开头的记录-字符匹配以特定字符或者字符串开头的文本"><a class="markdownIt-Anchor" href="#1查询以特定字符或字符串开头的记录-字符匹配以特定字符或者字符串开头的文本"></a> 1.查询以特定字符或字符串开头的记录 字符‘^’匹配以特定字符或者字符串开头的文本。</h4>
<p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2查询以特定字符或字符串结尾的记录-字符匹配以特定字符或者字符串结尾的文本"><a class="markdownIt-Anchor" href="#2查询以特定字符或字符串结尾的记录-字符匹配以特定字符或者字符串结尾的文本"></a> 2.查询以特定字符或字符串结尾的记录 字符‘$’匹配以特定字符或者字符串结尾的文本。</h4>
<p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3用符号来替代字符串中的任意一个字符-字符匹配任意一个字符"><a class="markdownIt-Anchor" href="#3用符号来替代字符串中的任意一个字符-字符匹配任意一个字符"></a> 3.用符号&quot;.&quot;来替代字符串中的任意一个字符 字符‘.’匹配任意一个字符。</h4>
<p>在fruits表中，查询f_name字段值 包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4使用和来匹配多个字符-星号匹配前面的字符任意多次包括0次"><a class="markdownIt-Anchor" href="#4使用和来匹配多个字符-星号匹配前面的字符任意多次包括0次"></a> 4.使用&quot;<em>“和”+&quot;来匹配多个字符 星号‘</em>’匹配前面的字符任意多次，包括0次。</h4>
<p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5匹配指定字符串-正则表达式可以匹配指定字符串只要这个字符串在查询文本中即可如要匹配多个-字符串多个字符串之间使用分隔符隔开"><a class="markdownIt-Anchor" href="#5匹配指定字符串-正则表达式可以匹配指定字符串只要这个字符串在查询文本中即可如要匹配多个-字符串多个字符串之间使用分隔符隔开"></a> 5.匹配指定字符串 正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个 字符串，多个字符串之间使用分隔符‘|’隔开。</h4>
<p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中 间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中 出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p>
<p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name like &#x27;on&#x27;;</span><br><span class="line">Empty set(0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6匹配指定字符中的任意一个-方括号指定一个字符集合只匹配其中任何一个字符即为所查找的-文本"><a class="markdownIt-Anchor" href="#6匹配指定字符中的任意一个-方括号指定一个字符集合只匹配其中任何一个字符即为所查找的-文本"></a> 6.匹配指定字符中的任意一个 方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的 文本。</h4>
<p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#x27;[456]&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7匹配指定字符以外的字符-字符集合-匹配不在指定集合中的任何字符"><a class="markdownIt-Anchor" href="#7匹配指定字符以外的字符-字符集合-匹配不在指定集合中的任何字符"></a> 7.匹配指定字符以外的字符 “[^字符集合]” 匹配不在指定集合中的任何字符。</h4>
<p>在fruits表中，查询f_id字段中包含字母a<sub>e和数字1</sub>2以外字符的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="8使用n或者nm来指定字符串连续出现的次数-字符串n表示至少匹配n次前面的字符字符串-nm表示匹配前面的字符串不少于n次不多于m次-例如a2表示字母a连续出现至少2次也可以-大于2次a24表示字母a连续出现最少2次最多不能超过4次"><a class="markdownIt-Anchor" href="#8使用n或者nm来指定字符串连续出现的次数-字符串n表示至少匹配n次前面的字符字符串-nm表示匹配前面的字符串不少于n次不多于m次-例如a2表示字母a连续出现至少2次也可以-大于2次a24表示字母a连续出现最少2次最多不能超过4次"></a> 8.使用{n,}或者{n,m}来指定字符串连续出现的次数 “字符串{n,}”表示至少匹配n次前面的字符；“字符串 {n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以 大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。</h4>
<p>在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;ba&#123;1,3&#125;&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五-排序与分页"><a class="markdownIt-Anchor" href="#五-排序与分页"></a> 五、排序与分页</h2>
<h3 id="1排序数据"><a class="markdownIt-Anchor" href="#1排序数据"></a> 1.排序数据</h3>
<h4 id="11排序规则"><a class="markdownIt-Anchor" href="#11排序规则"></a> 1.1排序规则</h4>
<ul>
<li>使用ORDER BY子句排序
<ul>
<li>ASC(ascend)：升序</li>
<li>DESC(descend)：降序</li>
</ul>
</li>
<li>ORDER BY子句在SELECT语句的结尾</li>
</ul>
<h4 id="12单列排序"><a class="markdownIt-Anchor" href="#12单列排序"></a> 1.2单列排序</h4>
<h4 id="13多列排序"><a class="markdownIt-Anchor" href="#13多列排序"></a> 1.3多列排序</h4>
<ul>
<li>可以使用不在SELECT列表中的列排序</li>
<li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li>
</ul>
<h3 id="2分页"><a class="markdownIt-Anchor" href="#2分页"></a> 2.分页</h3>
<h4 id="21实现规则"><a class="markdownIt-Anchor" href="#21实现规则"></a> 2.1实现规则</h4>
<ul>
<li>分页原理</li>
</ul>
<p>​		所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。</p>
<ul>
<li>MySQL中使用LIMIT实现分页</li>
<li>格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--前10条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 0,10;</span><br><span class="line">或者</span><br><span class="line">SELECT * FROM 表名 LIMIT 10;</span><br><span class="line">--第11至20条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 10,10;</span><br><span class="line">--第21至30条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 20,10;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p>
</blockquote>
<ul>
<li>分页显示公式：（当前页数-1）*每页条数，每页条数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table</span><br><span class="line">LIMIT(PageNo - 1)*PageSize,PageSize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>LIMIT子句必须放在整个SELECT语句的最后</li>
</ul>
<blockquote>
<p>约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1条，就可以使用LIMIT1，告诉SELECT语句只需要返回一条记录即可。这样的好处就是SELECT不需要扫描完整的表，只需要检索一条符合条件的记录即可返回。</p>
</blockquote>
<h4 id="22拓展"><a class="markdownIt-Anchor" href="#22拓展"></a> 2.2拓展</h4>
<p>在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关 键字，而且需要放到 SELECT 语句的最后面。</p>
<ul>
<li>如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是 DB2，使用 FETCH FIRST 5 ROWS ONLY 这样的关键字：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是 Oracle，你需要基于 ROWNUM 来统计行数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="六-多表查询"><a class="markdownIt-Anchor" href="#六-多表查询"></a> 六、多表查询</h2>
<h3 id="1笛卡尔积交互连接的理解"><a class="markdownIt-Anchor" href="#1笛卡尔积交互连接的理解"></a> 1.笛卡尔积（交互连接）的理解</h3>
<ul>
<li>笛卡尔积的错误会在下面条件下产生：
<ul>
<li>省略多个表的连接条件</li>
<li>连接条件（或关联关系）无效</li>
<li>所有表中的所有行互相连接</li>
</ul>
</li>
<li>为了避免笛卡尔积，可以在WHERE加入有效的连接条件</li>
<li>在表中有相同列时，在列名之前加上表名前缀</li>
</ul>
<h3 id="2多表查询分类讲解"><a class="markdownIt-Anchor" href="#2多表查询分类讲解"></a> 2.多表查询分类讲解</h3>
<p>分类1：等值连接VS非等值连接</p>
<h4 id="等值连接"><a class="markdownIt-Anchor" href="#等值连接"></a> 等值连接</h4>
<h5 id="1多个连接条件与and操作符"><a class="markdownIt-Anchor" href="#1多个连接条件与and操作符"></a> 1.多个连接条件与AND操作符</h5>
<h5 id="2区分重复的列名"><a class="markdownIt-Anchor" href="#2区分重复的列名"></a> 2.区分重复的列名</h5>
<ul>
<li>多个表中有相同列时，必须在列名之前加上表名前缀</li>
<li>在不同表中具有相同列名的列可以用表名加以区分</li>
</ul>
<h5 id="3表的别名"><a class="markdownIt-Anchor" href="#3表的别名"></a> 3.表的别名</h5>
<ul>
<li>使用别名可以简化查询</li>
<li>列名前使用表名前缀可以提高查询效率</li>
</ul>
<blockquote>
<p>注意：</p>
<p>如果我们使用了表的别名，在查询字段中、过滤条件就只能使用别名进行代替，不能使用原有的表名，否则会报错</p>
</blockquote>
<h5 id="4连接多个表"><a class="markdownIt-Anchor" href="#4连接多个表"></a> 4.连接多个表</h5>
<ul>
<li>连接n个表，至少需要n-1个连接条件。</li>
<li>在SQL优化角度，建议多变查询时，每个字段前都指明其所在的表。</li>
</ul>
<h4 id="非等值连接"><a class="markdownIt-Anchor" href="#非等值连接"></a> 非等值连接</h4>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_09-17-57.png"
                         style="zoom:50%;" 
                 >
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name,e.salary,j.grade_level</span><br><span class="line">FROM employees e,job_grades j</span><br><span class="line">WHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分类2：自然连接VS非自然连接</p>
<ul>
<li>内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行</li>
<li>外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。</li>
<li>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。</li>
<li>如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</li>
</ul>
<h3 id="3sql99语法实现多表查询"><a class="markdownIt-Anchor" href="#3sql99语法实现多表查询"></a> 3.SQL99语法实现多表查询</h3>
<h4 id="31语法结构"><a class="markdownIt-Anchor" href="#31语法结构"></a> 3.1.语法结构</h4>
<ul>
<li>使用JOIN…ON子句创建连接的语法结构：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT table1.column, table2.column,table3.column</span><br><span class="line">	FROM table1</span><br><span class="line">		JOIN table2 ON table1 和 table2 的连接条件</span><br><span class="line">		JOIN table3 ON table2 和 table3 的连接条件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>语法说明：
<ul>
<li>可以使用ON子句指定额外的连接条件</li>
<li>这个连接条件是其他条件分开的</li>
<li>ON子句使语句具有更高的易读性</li>
<li>关键字JOIN、INNER JOIN、CROSSJOIN的含义是一样的，都表示内连接</li>
</ul>
</li>
</ul>
<h4 id="32内连接inner-join的实现"><a class="markdownIt-Anchor" href="#32内连接inner-join的实现"></a> 3.2内连接（INNER JOIN）的实现</h4>
<ul>
<li>语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 INNER JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.employee_id, e.last_name, e.department_id,</span><br><span class="line">		d.department_id, d.location_id</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON (e.department_id = d.department_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="33外连接outer-join的实现"><a class="markdownIt-Anchor" href="#33外连接outer-join的实现"></a> 3.3外连接（OUTER JOIN）的实现</h4>
<h5 id="331左外连接left-outer-join"><a class="markdownIt-Anchor" href="#331左外连接left-outer-join"></a> 3.3.1左外连接（LEFT OUTER JOIN）</h5>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 LEFT JOIN　B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name, e.department_id, d.department_name</span><br><span class="line">FROM employees e</span><br><span class="line">LEFT OUTER JOIN departments d</span><br><span class="line">ON (e.department_id = d.department_id) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="332右外连接right-outer-join"><a class="markdownIt-Anchor" href="#332右外连接right-outer-join"></a> 3.3.2右外连接（RIGHT OUTER JOIN）</h5>
<ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 RIGHT JOIN B表</span><br><span class="line">ON 关联字段</span><br><span class="line">WHERE 等其他子句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name, e.department_id, d.department_name</span><br><span class="line">FROM employees e</span><br><span class="line">RIGHT OUTER JOIN departments d</span><br><span class="line">ON (e.department_id = d.department_id) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，LEFT JOIN　和　RIGHT　JOIN　只存在于SQL９９及以后的标准中，在SQL92中不存在，只能用（＋）表示</p>
</blockquote>
<h5 id="333满外连接full-outer-join"><a class="markdownIt-Anchor" href="#333满外连接full-outer-join"></a> 3.3.3满外连接(FULL OUTER JOIN)</h5>
<ul>
<li>满外连接的结果=左右表匹配的数据+做表没有匹配到的数据+右表没有匹配到的数据。</li>
<li>SQL99是支持满外连接的，使用FULL JOIN或FULL OUTER JOIN来实现。</li>
<li>需要注意的是，MySQL不支持FULL JOIN，但是可以用LEFT JOIN UNION RIGHT JOIN代替。</li>
</ul>
<h3 id="4union的使用"><a class="markdownIt-Anchor" href="#4union的使用"></a> 4.UNION的使用</h3>
<p><strong>合并查询结果</strong>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。哥哥SELECT语句之间使用UNION或UNION ALL关键字分隔。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT colum,... FROM table1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT colum,... FROM table2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="union操作符"><a class="markdownIt-Anchor" href="#union操作符"></a> UNION操作符</h4>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_16-37-23.png"
                         style="zoom:50%;" 
                 >
<p>UNION操作符返回两个查询的结果集的并集，去除重复记录。</p>
<h4 id="union-all操作符"><a class="markdownIt-Anchor" href="#union-all操作符"></a> UNION ALL操作符</h4>
<img    
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_16-38-48.png"
                         style="zoom:50%;" 
                 >
<p>NUION ALL操作符返回两个查询的结果集。对于两个结果集的重复部分，不去重。</p>
<blockquote>
<p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
</blockquote>
<p>举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,cname FROM t_chinamale WHERE csex=&#x27;男&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT id,tname FROM t_usmale WHERE tGender=&#x27;male&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="57种sql-join的实现"><a class="markdownIt-Anchor" href="#57种sql-join的实现"></a> 5.7种SQL JOIN的实现</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_16-49-09.png"
                        alt="" 
                 ></p>
<h3 id="6sql99语法新特性"><a class="markdownIt-Anchor" href="#6sql99语法新特性"></a> 6.SQL99语法新特性</h3>
<h4 id="61自然连接"><a class="markdownIt-Anchor" href="#61自然连接"></a> 6.1自然连接</h4>
<p>在SQL92标准中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">AND e.`manager_id` = d.`manager_id`;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 SQL99 中你可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e NATURAL JOIN departments d;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="62using连接"><a class="markdownIt-Anchor" href="#62using连接"></a> 6.2USING连接</h4>
<p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配 合JOIN一起使用。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">USING (department_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="七-单行函数"><a class="markdownIt-Anchor" href="#七-单行函数"></a> 七、单行函数</h2>
<h3 id="1函数的理解"><a class="markdownIt-Anchor" href="#1函数的理解"></a> 1.函数的理解</h3>
<p>两种SQL函数</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_17-03-40.png"
                        alt="" 
                 ></p>
<p>单行函数</p>
<ul>
<li>操作数据对象</li>
<li>接受参数返回一个结果</li>
<li>只对一行进行变换</li>
<li>每行返回一个结果</li>
<li>可以嵌套</li>
<li>参数可以是一列或一个值</li>
</ul>
<h3 id="2数值函数"><a class="markdownIt-Anchor" href="#2数值函数"></a> 2.数值函数</h3>
<h4 id="21基本函数"><a class="markdownIt-Anchor" href="#21基本函数"></a> 2.1基本函数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_17-12-36.png"
                        alt="" 
                 ></p>
<h4 id="22角度与弧度互换函数"><a class="markdownIt-Anchor" href="#22角度与弧度互换函数"></a> 2.2角度与弧度互换函数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_17-13-52.png"
                        alt="" 
                 ></p>
<p>知识链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弧度（radian）是一个用来度量角度的单位。它被定义为在圆的周长上的一个弧所对应的半径长度。</span><br><span class="line"></span><br><span class="line">具体来说，如果一个扇形的弧长等于其半径的长度，那么这个角度就是1弧度。以弧度为单位的角度可以用小数或带π的分数来表示。</span><br><span class="line"></span><br><span class="line">以下是一些常见的弧度值及其对应的角度：</span><br><span class="line"></span><br><span class="line">π弧度 ≈ 180°：这是一个排满整个圆的角度。</span><br><span class="line">π/2弧度 ≈ 90°：这是一个直角的角度。</span><br><span class="line">π/3弧度 ≈ 60°：这是一个等边三角形的角度。</span><br><span class="line">π/4弧度 ≈ 45°：这是一个正方形对角线的角度。</span><br><span class="line">π/6弧度 ≈ 30°：这是一个正三角形的角度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="23三角函数"><a class="markdownIt-Anchor" href="#23三角函数"></a> 2.3三角函数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-06_17-17-27.png"
                        alt="" 
                 ></p>
<h4 id="24指数与对数"><a class="markdownIt-Anchor" href="#24指数与对数"></a> 2.4指数与对数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-08-24.png"
                        alt="" 
                 ></p>
<h4 id="25进制间的转换"><a class="markdownIt-Anchor" href="#25进制间的转换"></a> 2.5进制间的转换</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-09-04.png"
                        alt="" 
                 ></p>
<h3 id="3字符串函数"><a class="markdownIt-Anchor" href="#3字符串函数"></a> 3.字符串函数</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-10-19.png"
                        alt="" 
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-10-51.png"
                        alt="" 
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-11-06.png"
                        alt="" 
                 ></p>
<blockquote>
<p>注意：MySQL中，字符串的位置是从1开始的。</p>
</blockquote>
<h3 id="4日期和时间函数"><a class="markdownIt-Anchor" href="#4日期和时间函数"></a> 4.日期和时间函数</h3>
<h4 id="41获取日期-时间"><a class="markdownIt-Anchor" href="#41获取日期-时间"></a> 4.1获取日期、时间</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-12-38.png"
                        alt="" 
                 ></p>
<h4 id="42日期与时间戳的转换"><a class="markdownIt-Anchor" href="#42日期与时间戳的转换"></a> 4.2日期与时间戳的转换</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-13-16.png"
                        alt="" 
                 ></p>
<h4 id="43获取月分-星期-星期数-天数等函数"><a class="markdownIt-Anchor" href="#43获取月分-星期-星期数-天数等函数"></a> 4.3获取月分、星期、星期数、天数等函数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-17-43.png"
                        alt="" 
                 ></p>
<h4 id="44日期的操作函数"><a class="markdownIt-Anchor" href="#44日期的操作函数"></a> 4.4日期的操作函数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-18-09.png"
                        alt="" 
                 ></p>
<p>EXTRACT(type FROM date)函数中type的取值与含义：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-18-33.png"
                        alt="" 
                 ></p>
<h4 id="45时间和秒数转换的函数"><a class="markdownIt-Anchor" href="#45时间和秒数转换的函数"></a> 4.5时间和秒数转换的函数</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-19-05.png"
                        alt="" 
                 ></p>
<h4 id="46计算日期和时间的函数"><a class="markdownIt-Anchor" href="#46计算日期和时间的函数"></a> 4.6计算日期和时间的函数</h4>
<h5 id="第1组"><a class="markdownIt-Anchor" href="#第1组"></a> 第1组：</h5>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-19-46.png"
                        alt="" 
                 ></p>
<p>上述函数中type的取值：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-20-23.png"
                        alt="" 
                 ></p>
<h5 id="第2组"><a class="markdownIt-Anchor" href="#第2组"></a> 第2组：</h5>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-20-48.png"
                        alt="" 
                 ></p>
<h4 id="47日期的格式化与解析"><a class="markdownIt-Anchor" href="#47日期的格式化与解析"></a> 4.7日期的格式化与解析</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-21-22.png"
                        alt="" 
                 ></p>
<p>上述非GET_FORMAT函数中fmt参数常用的格式符：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-22-28.png"
                        alt="" 
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-22-46.png"
                        alt="" 
                 ></p>
<h3 id="5流程控制函数"><a class="markdownIt-Anchor" href="#5流程控制函数"></a> 5.流程控制函数</h3>
<p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-25-01.png"
                        alt="" 
                 ></p>
<h3 id="6加密与解密函数"><a class="markdownIt-Anchor" href="#6加密与解密函数"></a> 6.加密与解密函数</h3>
<p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-27-53.png"
                        alt="" 
                 ></p>
<p>可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。</p>
<h3 id="7mysql信息函数"><a class="markdownIt-Anchor" href="#7mysql信息函数"></a> 7.MySQL信息函数</h3>
<p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-30-13.png"
                        alt="" 
                 ></p>
<h3 id="8其他函数"><a class="markdownIt-Anchor" href="#8其他函数"></a> 8.其他函数</h3>
<p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视 的。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-30-49.png"
                        alt="" 
                 ></p>
<h2 id="八-聚合函数"><a class="markdownIt-Anchor" href="#八-聚合函数"></a> 八、聚合函数</h2>
<h3 id="1聚合函数介绍"><a class="markdownIt-Anchor" href="#1聚合函数介绍"></a> 1.聚合函数介绍</h3>
<ul>
<li>什么是聚合函数</li>
</ul>
<p>聚合函数作用于一组数据，并对一组数据返回一个值</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-43-09.png"
                        alt="" 
                 ></p>
<ul>
<li>聚合函数类型
<ul>
<li>AVG()</li>
<li>SUM()</li>
<li>MAX()</li>
<li>MIN()</li>
<li>COUNT()</li>
</ul>
</li>
<li>聚合函数语法</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-45-31.png"
                        alt="" 
                 ></p>
<ul>
<li>聚合函数不能嵌套调用。比如不能出现类似&quot;AVG(SUM(字段名))&quot;形式的调用。</li>
</ul>
<h4 id="11avg和sum函数"><a class="markdownIt-Anchor" href="#11avg和sum函数"></a> 1.1AVG和SUM函数</h4>
<p>可以对数值型函数使用AVG和SUM函数。</p>
<h4 id="12min和max函数"><a class="markdownIt-Anchor" href="#12min和max函数"></a> 1.2MIN和MAX函数</h4>
<p>可以对任意数据类型的数据使用MIN和MAX函数。</p>
<h4 id="13count函数"><a class="markdownIt-Anchor" href="#13count函数"></a> 1.3COUNT函数</h4>
<ul>
<li>COUNT(*)返回表中记录总数，适用于任意数据类型。</li>
<li>COUNT(expr)返回expr不为空的记录总数。</li>
<li>问：用count（*），count（1），count（列名）谁好呢？
<ul>
<li>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好 于具体的count(列名)。</li>
</ul>
</li>
<li>问：能不能使用count(列名)替换count(*)?
<ul>
<li>不要使用 count(列名)来替代 count(<em>) ， count(</em>) 是 SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</li>
</ul>
</li>
</ul>
<h3 id="2group-by"><a class="markdownIt-Anchor" href="#2group-by"></a> 2.GROUP BY</h3>
<h4 id="21基本使用"><a class="markdownIt-Anchor" href="#21基本使用"></a> 2.1基本使用</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_14-58-45.png"
                        alt="" 
                 ></p>
<p>可以使用GROUP BY子句将表中的数据分成若干组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column, group_function(column)</span><br><span class="line">FROM table</span><br><span class="line">[WHERE condition]</span><br><span class="line">[GROUP BY group_by_expression]</span><br><span class="line">[ORDER BY column];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>明确：WHERE一定放在FROM后面</p>
</blockquote>
<p>在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>包含在GROUP BY子句中的列不必包含在SELECT列表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="22使用多个列分组"><a class="markdownIt-Anchor" href="#22使用多个列分组"></a> 2.2使用多个列分组</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_15-06-13.png"
                        alt="" 
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id dept_id, job_id, SUM(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id, job_id ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="23group-by中使用with-rollup"><a class="markdownIt-Anchor" href="#23group-by中使用with-rollup"></a> 2.3GROUP BY中使用WITH ROLLUP</h4>
<p>使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &gt; 80</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
<p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY时互相排斥的。</p>
</blockquote>
<h3 id="3having"><a class="markdownIt-Anchor" href="#3having"></a> 3.HAVING</h3>
<h4 id="31基本使用"><a class="markdownIt-Anchor" href="#31基本使用"></a> 3.1基本使用</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_15-10-20.png"
                        alt="" 
                 ></p>
<p>过滤分组：HAVING子句</p>
<ol>
<li>行已经被分组</li>
<li>使用了聚合函数</li>
<li>满足HAVING子句中条件的分组将被显示</li>
<li>HAVING不能单独使用，必须要跟GROUP BY一起使用</li>
</ol>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_15-11-52.png"
                        alt="" 
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id, MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt;10000 ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>非法使用聚合函数：不能在WHERE子句中使用聚合函数  例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE AVG(salary) &gt; 8000</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="32where和having的对比"><a class="markdownIt-Anchor" href="#32where和having的对比"></a> 3.2WHERE和HAVING的对比！</h4>
<blockquote>
<p>区别1：WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算机函数作为筛选条件；HAVING必须要与GROUP BY配合使用，可以把分组计算的函数和分组字段作为筛选条件。</p>
</blockquote>
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。</p>
<blockquote>
<p>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选。</p>
</blockquote>
<p>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。</p>
<p>小结如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-07_16-01-15.png"
                        alt="" 
                 ></p>
<p>开发中的选择：</p>
<p>WHERE和HAVING也不是互相排斥的，我们可以在一个查询里面同时使用WHERE和HAVING。包含分组统计函数的条件用HAVING，普通条件用WHERE。这样，我们就既利用了WHERE条件的高效快捷，又发挥了HAVING可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会又很大的差别。</p>
<h3 id="4select的执行过程"><a class="markdownIt-Anchor" href="#4select的执行过程"></a> 4.SELECT的执行过程</h3>
<h4 id="41查询的结构"><a class="markdownIt-Anchor" href="#41查询的结构"></a> 4.1查询的结构</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：</span><br><span class="line">SELECT ...,....,...</span><br><span class="line">FROM ...,...,....</span><br><span class="line">WHERE 多表的连接条件</span><br><span class="line">AND 不包含组函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含组函数的过滤条件</span><br><span class="line">ORDER BY ... ASC/DESC</span><br><span class="line">LIMIT ...,...</span><br><span class="line">#方式2：</span><br><span class="line">SELECT ...,....,...</span><br><span class="line">FROM ... JOIN ...</span><br><span class="line">ON 多表的连接条件</span><br><span class="line">JOIN ...</span><br><span class="line">ON ...</span><br><span class="line">WHERE 不包含组函数的过滤条件</span><br><span class="line">AND/OR 不包含组函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含组函数的过滤条件</span><br><span class="line">ORDER BY ... ASC/DESC</span><br><span class="line">LIMIT ...,...</span><br><span class="line">#其中：</span><br><span class="line">#（1）from：从哪些表中筛选</span><br><span class="line">#（2）on：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（3）where：从表中筛选的条件</span><br><span class="line">#（4）group by：分组依据</span><br><span class="line">#（5）having：在统计结果中再次筛选</span><br><span class="line">#（6）order by：排序</span><br><span class="line">#（7）limit：分页</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="42select执行顺序"><a class="markdownIt-Anchor" href="#42select执行顺序"></a> 4.2SELECT执行顺序</h4>
<p>你需要记住SELECT查询时的两个顺序：</p>
<h5 id="421关键字的顺序是不能颠倒的"><a class="markdownIt-Anchor" href="#421关键字的顺序是不能颠倒的"></a> 4.2.1关键字的顺序是不能颠倒的：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="422select语句的执行顺序在mysql和oracle中select执行顺序基本相同"><a class="markdownIt-Anchor" href="#422select语句的执行顺序在mysql和oracle中select执行顺序基本相同"></a> 4.2.2SELECT语句的执行顺序（在MySQL和Oracle中，SELECT执行顺序基本相同）：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比如你写了一个SQL语句，那么它的关键字顺序和执行顺序是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5</span><br><span class="line">FROM player JOIN team ON player.team_id = team.team_id # 顺序 1</span><br><span class="line">WHERE height &gt; 1.80 # 顺序 2</span><br><span class="line">GROUP BY player.team_id # 顺序 3</span><br><span class="line">HAVING num &gt; 2 # 顺序 4</span><br><span class="line">ORDER BY num DESC # 顺序 6</span><br><span class="line">LIMIT 2 # 顺序 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在SELECT语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在SQL的执行过程中，对于我们来说是不可见的。</p>
<h4 id="43sql的执行原理"><a class="markdownIt-Anchor" href="#43sql的执行原理"></a> 4.3SQL的执行原理</h4>
<p>SELECT是先执行FROM这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li>首先通过CROSS JOIN求笛卡尔积，相当于得到虚拟表vt1-1；</li>
<li>过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li>
</ol>
<p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。</p>
<p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1 ，就可以在此基础上再进行 WHERE 阶 段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2 。</p>
<p>然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。</p>
<p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。</p>
<p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。</p>
<p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。</p>
<p>最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。</p>
<p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。 同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序，所谓底层运行的原理，就是我们刚才讲到的执行顺序。</p>
<h2 id="九-子查询"><a class="markdownIt-Anchor" href="#九-子查询"></a> 九、子查询</h2>
<h3 id="1需求分析与问题解决"><a class="markdownIt-Anchor" href="#1需求分析与问题解决"></a> 1.需求分析与问题解决</h3>
<h4 id="11实际问题"><a class="markdownIt-Anchor" href="#11实际问题"></a> 1.1实际问题</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-14-25.png"
                        alt="" 
                 ></p>
<p>解决方案 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询：</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="12子查询的基本应用"><a class="markdownIt-Anchor" href="#12子查询的基本应用"></a> 1.2子查询的基本应用</h4>
<ul>
<li>子查询的基本语法结构：</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-16-09.png"
                        alt="" 
                 ></p>
<ul>
<li>子查询（内查询）在主查询之前依次执行完成</li>
<li>子查询的结果被主查询（外查询）使用</li>
<li>注意事项：
<ul>
<li>子查询要包含括号内</li>
<li>将子查询放在比较条件的右侧</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
</ul>
<h4 id="13子查询的分类"><a class="markdownIt-Anchor" href="#13子查询的分类"></a> 1.3子查询的分类</h4>
<h5 id="分类方式1"><a class="markdownIt-Anchor" href="#分类方式1"></a> 分类方式1：</h5>
<p>我们内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询。</p>
<ul>
<li>单行子查询</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-22-03.png"
                        alt="" 
                 ></p>
<ul>
<li>多行子查询</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-23-00.png"
                        alt="" 
                 ></p>
<h5 id="分类方式2"><a class="markdownIt-Anchor" href="#分类方式2"></a> 分类方式2：</h5>
<p>我们内查询是否被执行多行，将子查询划分为相关（或关联）子查询和不相关（或非关联）子查询。</p>
<p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p>
<p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p>
<h3 id="2单行子查询"><a class="markdownIt-Anchor" href="#2单行子查询"></a> 2.单行子查询</h3>
<h4 id="21单行比较操作符"><a class="markdownIt-Anchor" href="#21单行比较操作符"></a> 2.1单行比较操作符</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-29-16.png"
                        alt="" 
                 ></p>
<h4 id="22代码示例"><a class="markdownIt-Anchor" href="#22代码示例"></a> 2.2代码示例</h4>
<p>题目：查询工资大于149号员工工资的员工信息</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-30-30.png"
                        alt="" 
                 ></p>
<h4 id="23having中的子查询"><a class="markdownIt-Anchor" href="#23having中的子查询"></a> 2.3HAVING中的子查询</h4>
<ul>
<li>首先执行子查询</li>
<li>向主查询中的HAVING子句返回结果。</li>
</ul>
<p>题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id, MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary) &gt;</span><br><span class="line">                    (SELECT MIN(salary)</span><br><span class="line">                    FROM employees</span><br><span class="line">                    WHERE department_id = 50);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="24case中的子查询"><a class="markdownIt-Anchor" href="#24case中的子查询"></a> 2.4CASE中的子查询</h4>
<p>在CASE表达式中使用单例子查询：</p>
<p>题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name,</span><br><span class="line">        (CASE department_id</span><br><span class="line">        WHEN</span><br><span class="line">            (SELECT department_id FROM departments</span><br><span class="line">                WHERE location_id = 1800)</span><br><span class="line">        THEN &#x27;Canada&#x27; ELSE &#x27;USA&#x27; END) location</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="25子查询中的空值问题"><a class="markdownIt-Anchor" href="#25子查询中的空值问题"></a> 2.5子查询中的空值问题</h4>
<blockquote>
<p>子查询不返回任何行</p>
</blockquote>
<h4 id="26非法使用子查询"><a class="markdownIt-Anchor" href="#26非法使用子查询"></a> 2.6非法使用子查询</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary =</span><br><span class="line">                (SELECT MIN(salary)</span><br><span class="line">                FROM employees</span><br><span class="line">                GROUP BY department_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>多行子查询使用单行比较符</p>
</blockquote>
<h3 id="3多行子查询"><a class="markdownIt-Anchor" href="#3多行子查询"></a> 3.多行子查询</h3>
<ul>
<li>也称为集合比较子查询</li>
<li>内查询返回多行</li>
<li>使用多行比较操作符</li>
</ul>
<h4 id="31多行比较操作符"><a class="markdownIt-Anchor" href="#31多行比较操作符"></a> 3.1多行比较操作符</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-40-05.png"
                        alt="" 
                 ></p>
<blockquote>
<p>体会ANY和ALL的区别</p>
</blockquote>
<h4 id="32代码示例"><a class="markdownIt-Anchor" href="#32代码示例"></a> 3.2代码示例</h4>
<p>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-43-55.png"
                        alt="" 
                 ></p>
<h4 id="33空值问题"><a class="markdownIt-Anchor" href="#33空值问题"></a> 3.3空值问题</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id NOT IN (</span><br><span class="line">                            SELECT manager_id</span><br><span class="line">                            FROM employees</span><br><span class="line">                            );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4相关子查询"><a class="markdownIt-Anchor" href="#4相关子查询"></a> 4.相关子查询</h3>
<h4 id="41相关子查询执行流程"><a class="markdownIt-Anchor" href="#41相关子查询执行流程"></a> 4.1相关子查询执行流程</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-46-23.png"
                        alt="" 
                 ></p>
<h4 id="42代码示例"><a class="markdownIt-Anchor" href="#42代码示例"></a> 4.2代码示例</h4>
<p>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</p>
<h5 id="方式一相关子查询"><a class="markdownIt-Anchor" href="#方式一相关子查询"></a> 方式一：相关子查询</h5>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-08_08-49-36.png"
                        alt="" 
                 ></p>
<h5 id="方式二在from中使用子查询"><a class="markdownIt-Anchor" href="#方式二在from中使用子查询"></a> 方式二：在FROM中使用子查询</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name,salary,e1.department_id</span><br><span class="line">FROM employees e1,(SELECT department_id,AVG(salary) 							dept_avg_sal FROM employees GROUP</span><br><span class="line">                    BY department_id) e2</span><br><span class="line">WHERE e1.`department_id` = e2.department_id</span><br><span class="line">AND e2.dept_avg_sal &lt; e1.`salary`;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名，把它当成一张“临时虚拟的表”来使用</p>
</blockquote>
<p>在ORDER BY中使用子查询：</p>
<p>题目：查询员工的id、salary，按照department_name排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary</span><br><span class="line">FROM employees e</span><br><span class="line">ORDER BY (</span><br><span class="line">        SELECT department_name</span><br><span class="line">        FROM departments d</span><br><span class="line">        WHERE e.`department_id` = d.`department_id`</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.3EXISTS与NOT EXISTS关键字</p>
<ul>
<li>关联子查询通常也会和EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li>
<li>如果在子查询中不存在满足条件的行：
<ul>
<li>条件返回FALSE</li>
<li>继续在子查询中继续查找</li>
<li>条件返回</li>
</ul>
</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li>
</ul>
<p>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, department_id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE EXISTS ( SELECT *</span><br><span class="line">                FROM employees e2</span><br><span class="line">                WHERE e2.manager_id =</span><br><span class="line">                    e1.employee_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="44相关更新"><a class="markdownIt-Anchor" href="#44相关更新"></a> 4.4相关更新</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table1 alias1</span><br><span class="line">SET column = (SELECT expression</span><br><span class="line">                FROM table2 alias2</span><br><span class="line">                WHERE alias1.column = alias2.column);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p>
<p>题目：在employees中增加一个department_name字段，数据为员工对应的部门名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1）</span><br><span class="line">ALTER TABLE employees</span><br><span class="line">ADD(department_name VARCHAR2(14));</span><br><span class="line"></span><br><span class="line"># 2）</span><br><span class="line">UPDATE employees e</span><br><span class="line">SET department_name = (SELECT department_name</span><br><span class="line">                        FROM departments d</span><br><span class="line">                        WHERE e.department_id = d.department_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="45相关删除"><a class="markdownIt-Anchor" href="#45相关删除"></a> 4.5相关删除</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table1 alias1</span><br><span class="line">WHERE column operator (SELECT expression</span><br><span class="line">                        FROM table2 alias2</span><br><span class="line">                        WHERE alias1.column = alias2.column);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用相关子查询一句一个表中的数据删除另一个表的数据。</p>
<p>题目：删除表employees中，其与emp_history表皆有的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM employees e</span><br><span class="line">WHERE employee_id in</span><br><span class="line">                    (SELECT employee_id</span><br><span class="line">                    FROM emp_history</span><br><span class="line">                    WHERE employee_id = e.employee_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5抛一个思考题"><a class="markdownIt-Anchor" href="#5抛一个思考题"></a> 5.抛一个思考题</h3>
<p>问题：一个问题用两种方式解决，分别是自查询、子查询，哪种方式好</p>
<p>解答：自连接好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为DBMS的处理过程中，对于自连接的处理速度要比子查询快得多。</span><br><span class="line">可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分DBMS中都对自连接处理进行了优化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十-创建和管理表"><a class="markdownIt-Anchor" href="#十-创建和管理表"></a> 十、创建和管理表</h2>
<h3 id="1基础知识"><a class="markdownIt-Anchor" href="#1基础知识"></a> 1.基础知识</h3>
<h4 id="11一条数据存储的过程"><a class="markdownIt-Anchor" href="#11一条数据存储的过程"></a> 1.1一条数据存储的过程</h4>
<p>存储数据是处理数据的第一步。只有正确的把数据存储起来，我们才能有效的处理和分析。否则，只能是一团乱麻，无从下手。</p>
<p>在 MySQL 中， 一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-09_14-18-39.png"
                        alt="" 
                 ></p>
<p>我们要先创建一个数据库，而不是直接创建数据表呢？</p>
<p>因为从系统架构的层次上看，MySQL数据库系统从大到小一次是数据库服务器、数据库、数据表、数据表的行与列。</p>
<p>MySQL数据库服务器之前已经安装。所以我们就从创建数据库开始。</p>
<h4 id="12标识符命名规则"><a class="markdownIt-Anchor" href="#12标识符命名规则"></a> 1.2标识符命名规则</h4>
<ul>
<li>数据库名、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来</li>
<li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h4 id="13mysql中的数据类型"><a class="markdownIt-Anchor" href="#13mysql中的数据类型"></a> 1.3MySQL中的数据类型</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-09_14-25-06.png"
                        alt="" 
                 ></p>
<p>其中，常用的几种类型介绍如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-09_14-25-35.png"
                        alt="" 
                 ></p>
<h3 id="2创建和管理数据库"><a class="markdownIt-Anchor" href="#2创建和管理数据库"></a> 2.创建和管理数据库</h3>
<h4 id="21创建数据库"><a class="markdownIt-Anchor" href="#21创建数据库"></a> 2.1创建数据库</h4>
<ul>
<li>方式1：创建数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>方式2：创建数据库并指定字符集</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名 CHARACTER SET 字符集;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>方式3：判断数据库是否已经存在，不存在则创建数据库（推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果MySQL中已经存在相关的数据库，则忽悠创建语句，不再创建数据库。</p>
<blockquote>
<p>注意：DATABASE不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p>
</blockquote>
<h4 id="22使用数据库"><a class="markdownIt-Anchor" href="#22使用数据库"></a> 2.2使用数据库</h4>
<ul>
<li>查看当前所有的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASE;#有一个S，代表多个数据库</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前正在使用的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();	#使用的一个mysql中的全局函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看指定库下所有的表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES FROM 数据库名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看数据库的创建信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line">SHOW CREATE DATABASE 数据库名\G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>使用/切换数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：要操作表格和数据之前必须先说明是哪个数据库进行操作，否则就要对所有对象加上“数据库名”。</p>
</blockquote>
<h4 id="23修改数据库"><a class="markdownIt-Anchor" href="#23修改数据库"></a> 2.3修改数据库</h4>
<ul>
<li>更改数据库字符集</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET 字符集;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="24删除数据库"><a class="markdownIt-Anchor" href="#24删除数据库"></a> 2.4删除数据库</h4>
<blockquote>
<p>这里的操作知道就好，可不要随便使用</p>
</blockquote>
<ul>
<li>方式1：删除指定的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>方式2：删除指定的数据库(推荐)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3创建表"><a class="markdownIt-Anchor" href="#3创建表"></a> 3.创建表</h3>
<h4 id="31创建方式1"><a class="markdownIt-Anchor" href="#31创建方式1"></a> 3.1创建方式1</h4>
<ul>
<li>必须必备
<ul>
<li>CREATE TABLE权限</li>
<li>存储空间</li>
</ul>
</li>
<li>语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">    字段1, 数据类型 [约束条件] [默认值],</span><br><span class="line">    字段2, 数据类型 [约束条件] [默认值],</span><br><span class="line">    字段3, 数据类型 [约束条件] [默认值],</span><br><span class="line">    ……</span><br><span class="line">    [表约束条件]</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则床架数据表；如果当前数据库中已经存在要创建的数据库，则忽略建表语句，不再创建数据表。</p>
</blockquote>
<ul>
<li>必须指定：
<ul>
<li>表名</li>
<li>列名（或字段名），数据类型，长度</li>
</ul>
</li>
<li>可选指定：
<ul>
<li>约束条件</li>
<li>默认值</li>
</ul>
</li>
<li>创建表举例1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">    -- int类型</span><br><span class="line">    emp_id INT,</span><br><span class="line">    -- 最多保存20个中英文字符</span><br><span class="line">    emp_name VARCHAR(20),</span><br><span class="line">    -- 总位数不超过15位</span><br><span class="line">    salary DOUBLE,</span><br><span class="line">    -- 日期类型</span><br><span class="line">    birthday DATE</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC emp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-16_17-42-05.png"
                        alt="" 
                 ></p>
<p>MySQL在执行建表语句时，将id字段的类型设置为int(11),这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11.也可以在创建数据库表的时候指定数据的显示宽度。</p>
<ul>
<li>创建表举例2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">    -- int类型，自增</span><br><span class="line">    deptno INT(2) AUTO_INCREMENT,</span><br><span class="line">    dname VARCHAR(14),</span><br><span class="line">    loc VARCHAR(13),</span><br><span class="line">    -- 主键</span><br><span class="line">    PRIMARY KEY (deptno)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-16_17-45-15.png"
                        alt="" 
                 ></p>
<blockquote>
<p>MySQL8版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</p>
</blockquote>
<h4 id="32创建方式2"><a class="markdownIt-Anchor" href="#32创建方式2"></a> 3.2创建方式2</h4>
<ul>
<li>使用AS subquery选项，将创建表和插入数据结合起来</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-16_17-48-10.png"
                        alt="" 
                 ></p>
<ul>
<li>指定的列和子查询中的列要一一对应</li>
<li>通过列名和默认值定义列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp1 AS SELECT * FROM employees;</span><br><span class="line">CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept80</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, last_name, salary*12 ANNSAL, hire_date</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-07-16_17-51-51.png"
                        alt="" 
                 ></p>
<h4 id="33查看数据表结构"><a class="markdownIt-Anchor" href="#33查看数据表结构"></a> 3.3查看数据表结构</h4>
<p>在MySQL中创建号数据库之后，可以查看数据表的结构。在MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名\G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<h3 id="4修改表"><a class="markdownIt-Anchor" href="#4修改表"></a> 4.修改表</h3>
<p>修改表指的是修改数据库中已经存在的数据表的结构。</p>
<p>使用ALTER TABLE 语句可以实现：</p>
<ul>
<li>向已有的表中添加列</li>
<li>修改现有表中的列</li>
<li>删除现有表中的列</li>
<li>重命名现有表中的列</li>
</ul>
<h4 id="41追加一个列"><a class="markdownIt-Anchor" href="#41追加一个列"></a> 4.1追加一个列</h4>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [COLUMN] 字段名 字段类型 [FIRST|AFTER 字段名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80</span><br><span class="line">ADD job_id varchar(15);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-03_14-57-14.png"
                        alt="" 
                 ></p>
<h4 id="42修改一个列"><a class="markdownIt-Anchor" href="#42修改一个列"></a> 4.2修改一个列</h4>
<ul>
<li>可以修改列的数据类型，长度、默认值和位置</li>
<li>修改字段数据类型、长度、默认值、位置的语法格式如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY [COLUMN] 字段名1 字段类型 [DEFAULT 默认值] [FIRST|AFTER 字段名2];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80</span><br><span class="line">MODIFY last_name VARCHAR(30);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80</span><br><span class="line">MODIFY salary double(9,2) default 1000;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>对默认值的修改只影响今后对表的修改</li>
<li>此外，还可以通过此种方式修改列的约束。</li>
</ul>
<h4 id="43重命名一个列"><a class="markdownIt-Anchor" href="#43重命名一个列"></a> 4.3重命名一个列</h4>
<p>使用 CHANGE old_column new_column dataType 子语句重命名列。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="44删除一个列"><a class="markdownIt-Anchor" href="#44删除一个列"></a> 4.4删除一个列</h4>
<p>删除表中某个字段的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 【COLUMN】字段名</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80</span><br><span class="line">DROP COLUMN job_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5重命名表"><a class="markdownIt-Anchor" href="#5重命名表"></a> 5.重命名表</h3>
<ul>
<li>方式一：使用RENAME</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE emp</span><br><span class="line">TO myemp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>方式二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table dept</span><br><span class="line">RENAME [TO] detail_dept; -- [TO]可以省略</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>必须时对象的拥有者</li>
</ul>
<h3 id="6删除表"><a class="markdownIt-Anchor" href="#6删除表"></a> 6.删除表</h3>
<ul>
<li>在MySQL中，当一张数据表没有其他任何数据表形成关联关系时，可以将当前数据表直接删除。</li>
<li>数据和结构都被删除</li>
<li>所有正在运行的相关事务被提交</li>
<li>所有相关索引被删除</li>
<li>语法格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 数据表1,[,数据表2,数据表。。。];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存 在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE dept80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>DROP TABLE 语句不能回滚</strong></li>
</ul>
<h3 id="7清空表"><a class="markdownIt-Anchor" href="#7清空表"></a> 7.清空表</h3>
<ul>
<li>TRUNCATE TABLE语句：
<ul>
<li>删除表中所有的数据</li>
<li>释放表中的存储空间</li>
</ul>
</li>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE detail_dept;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>TRUNCATE<strong>语句不能回滚</strong>，而使用DELECT语句删除语句，可以回滚</p>
</li>
<li>
<p>对比：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = FALSE;</span><br><span class="line">DELETE FROM emp2;</span><br><span class="line">#TRUNCATE TABLE emp2;</span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>阿里开发规范： 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
</blockquote>
<h3 id="8内容拓展"><a class="markdownIt-Anchor" href="#8内容拓展"></a> 8.内容拓展</h3>
<h4 id="拓展1阿里巴巴java开发手册之mysql字段命名"><a class="markdownIt-Anchor" href="#拓展1阿里巴巴java开发手册之mysql字段命名"></a> 拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</h4>
<ul>
<li>【<strong>强制</strong>】表明、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
<ul>
<li>正确实例： aliyun_admin，rdc_config，level3_name</li>
<li>错误实例： AliyunAdmin，rdcConfig，level_3_name</li>
</ul>
</li>
<li>【<strong>强制</strong>】禁用保留字， 如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</li>
<li>【<strong>强制</strong>】表必备字段： id,create_by,  create_time,update_by,update_time。</li>
<li>【推荐】表的命名最好是遵循”业务名称_表的作用“。
<ul>
<li>例： alipay_task 、 force_project、 trade_config</li>
</ul>
</li>
<li>【推荐】库名与应用名称尽量一致。</li>
</ul>
<h4 id="拓展2如何理解清空表-删除表等操作需谨慎"><a class="markdownIt-Anchor" href="#拓展2如何理解清空表-删除表等操作需谨慎"></a> 拓展2：如何理解清空表、删除表等操作需谨慎？！</h4>
<p>表删除 操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信 息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行 备份 ，这样当操作失误时可 以对数据进行恢复，以免造成无法挽回的后果。 同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进 行完整的 备份 ，因为数据库的改变是 无法撤销 的，如果添加了一个不需要的字段，可以将其删除；相 同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p>
<h4 id="拓展3mysql8新特性-ddl的原子化"><a class="markdownIt-Anchor" href="#拓展3mysql8新特性-ddl的原子化"></a> 拓展3：MySQL8新特性-DDL的原子化</h4>
<p>在MySQL8.0版本中，InnoDB表中DDL支持事务完整性，即DDL操作要么成功要么回滚。DDL操作回滚日志写入到data dictionary数据字典表中mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p>
<p>分别在MySQL5.7版本和MySQL8.0版本中创建数据库和数据表，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mytest;</span><br><span class="line">USE mytest;</span><br><span class="line">CREATE TABLE book1(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(255)</span><br><span class="line">);</span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）在MySQL5.7版本中，测试步骤如下：删除数据表book1和数据表book2，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次查询数据库中的数据表名称，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1.</p>
<p>（2）在MySQL8.0版本中，测试步骤如下：删除数据表book1和数据表book2，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次查询数据库中的数据表名称，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_mytest |</span><br><span class="line">+------------------+</span><br><span class="line">| book1 |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，数据表book1并没有被删除。</p>
<h2 id="十一-数据处理之增删改"><a class="markdownIt-Anchor" href="#十一-数据处理之增删改"></a> 十一、数据处理之增删改</h2>
<h3 id="1插入数据"><a class="markdownIt-Anchor" href="#1插入数据"></a> 1.插入数据</h3>
<h4 id="11实际问题-2"><a class="markdownIt-Anchor" href="#11实际问题-2"></a> 1.1实际问题</h4>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-03_17-33-15.png"
                        alt="" 
                 ></p>
<h4 id="12方式1values的方式添加"><a class="markdownIt-Anchor" href="#12方式1values的方式添加"></a> 1.2方式1：VALUES的方式添加</h4>
<p>使用这种语法一次只能向表中插入一条数据。</p>
<p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES (value1,value2,....);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments</span><br><span class="line">VALUES (70, &#x27;Pub&#x27;, 100, 1700);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments</span><br><span class="line">VALUES (100, &#x27;Finance&#x27;, NULL, NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>情况2：为表中的指定字段插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(column1 [, column2, …, columnn])</span><br><span class="line">VALUES (value1 [,value2, …, valuen]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为定义时的默认值。</p>
<p>在INSERT字句中随意列出列名，但是一旦列出，VALUES中要插入的value1，…, valuen 需要与 column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments(department_id, department_name)</span><br><span class="line">VALUES (80, &#x27;IT&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>情况3：同时插入多条记录</p>
<p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name</span><br><span class="line">VALUES</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name(column1 [, column2, …, columnn])</span><br><span class="line">VALUES</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp(emp_id,emp_name)</span><br><span class="line">-&gt; VALUES (1001,&#x27;shkstart&#x27;),</span><br><span class="line">-&gt; (1002,&#x27;atguigu&#x27;),</span><br><span class="line">-&gt; (1003,&#x27;Tom&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3 Duplicates: 0 Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含 义如下：</p>
<p>●　Records：表明插入的记录条数。</p>
<p>●　Duplicates：表明插入时被忽略的记录，原因可能是这 些记录包含了重复的主键值。</p>
<p>●　Warnings：表明有问题的数据值，例如发生数据类型转换。</p>
<blockquote>
<p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<strong>效率更高</strong>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p>
</blockquote>
<p><strong>小结</strong>：</p>
<ul>
<li>VALUES也可以写成VALUE，但是VALUES时标准写法。</li>
<li>字符和日期数据应包括在单引号中。</li>
</ul>
<h4 id="13方式2将查询结果插入到表中"><a class="markdownIt-Anchor" href="#13方式2将查询结果插入到表中"></a> 1.3方式2：将查询结果插入到表中</h4>
<p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成语句即可快速地从一个或多个表中插入多行。</p>
<p>基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, …, tar_columnn])</span><br><span class="line">SELECT</span><br><span class="line">(src_column1 [, src_column2, …, src_columnn])</span><br><span class="line">FROM 源表名</span><br><span class="line">[WHERE condition]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在INSERT语句中加入子查询</li>
<li><strong>不必书写VALUES子句</strong></li>
<li>子查询中的值列表应与INSERT子句中的列名对应</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO emp2</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 90;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO sales_reps(id, name, salary, commission_pct)</span><br><span class="line">SELECT employee_id, last_name, salary, commission_pct</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id LIKE &#x27;%REP%&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2更新数据"><a class="markdownIt-Anchor" href="#2更新数据"></a> 2.更新数据</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-03_17-53-42.png"
                        alt="" 
                 ></p>
<ul>
<li>使用UPDATE语句更新数据。语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1=value1, column2=value2, … , column=valuen</span><br><span class="line">[WHERE condition]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>可以一次更新多条数据。</li>
<li>如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT = FALSE;</li>
<li>使用WHERE子句指定需要更新的数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE employees</span><br><span class="line">SET department_id = 70</span><br><span class="line">WHERE employee_id = 113;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果省略WHERE子句，则表中所有数据都将被更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE copy_emp</span><br><span class="line">SET department_id = 110;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>更新中的数据完整性错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE employees</span><br><span class="line">SET department_id = 55</span><br><span class="line">WHERE department_id = 110;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3删除数据"><a class="markdownIt-Anchor" href="#3删除数据"></a> 3.删除数据</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-05_20-10-01.png"
                        alt="" 
                 ></p>
<ul>
<li>使用DELECT语句从表中删除数据</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-05_20-11-25.png"
                        alt="" 
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELECT FROM table_name [WHERE &lt;condition&gt;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>table_name指定要执行删除操作的表;”[WHERE]“可选参数，指定删除条件，</p>
<p>如果没有WHERE子句，DELECT语句将删除表中的所有记录。</p>
<ul>
<li>使用WHERE子句删除指定的记录。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM departments</span><br><span class="line">WHERE department_name = &#x27;Finance&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果省略WHERE子句，则表中的全部数据将被删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM copy_emp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4mysql8新特性计算列"><a class="markdownIt-Anchor" href="#4mysql8新特性计算列"></a> 4.MySQL8新特性：计算列</h3>
<p>在MySQL8中，CREATE TABLE和ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p>
<p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。首先创建测试表tb1，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb1(</span><br><span class="line">id INT,</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">c INT GENERATED ALWAYS AS (a + b) VIRTUAL</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插入演示数据，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb1(a,b) VALUES (100,200);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询数据表tb1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tb1;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| id | a | b | c |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| NULL | 100 | 200 | 300 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更新数据中的数据，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE tb1 SET a = 500;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 1 Changed: 0 Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十二-mysql数据类型精讲"><a class="markdownIt-Anchor" href="#十二-mysql数据类型精讲"></a> 十二、MySQL数据类型精讲</h2>
<h3 id="1mysql中的数据类型"><a class="markdownIt-Anchor" href="#1mysql中的数据类型"></a> 1.MySQL中的数据类型</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_09-15-51.png"
                        alt="" 
                 ></p>
<p>常见数据类型的属性，如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_09-16-27.png"
                        alt="" 
                 ></p>
<h3 id="2整数类型"><a class="markdownIt-Anchor" href="#2整数类型"></a> 2.整数类型</h3>
<h4 id="21类型介绍"><a class="markdownIt-Anchor" href="#21类型介绍"></a> 2.1类型介绍</h4>
<p>整数类型一共有5种，包括  TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p>
<p>它们的区别如下表所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_09-19-48.png"
                        alt="" 
                 ></p>
<h4 id="22可选属性"><a class="markdownIt-Anchor" href="#22可选属性"></a> 2.2可选属性</h4>
<p><strong>整数类型的可选属性有三个：</strong></p>
<h5 id="221m"><a class="markdownIt-Anchor" href="#221m"></a> 2.2.1M</h5>
<p>M:表示显示宽度，M的取值范围是（0，255）.例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ZEROFILL”使用，表示用“0”填满宽度，否则指定显示宽度无效。</p>
<p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会阶段或插入失败？</p>
<p>答：不会u对插入的数据据有任何影响，还是按照类型的实际类型的实际宽度进行保存，即显示宽度与类型可以存储的值范围无关。从MySQL8开始，整数数据类型不推荐使用显示宽度属性。</p>
<p>整数数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_init1 (x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看表结构（MySQL5.7中显示如下，MySQL8中不显示范围）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc test_int1;</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| x | tinyint(4) | YES | | NULL | |</span><br><span class="line">| y | smallint(6) | YES | | NULL | |</span><br><span class="line">| z | mediumint(9) | YES | | NULL | |</span><br><span class="line">| m | int(11) | YES | | NULL | |</span><br><span class="line">| n | bigint(20) | YES | | NULL | |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TINYINT有符号数和无符号数的取值范围分别为-128<sub>127和0</sub>255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4，同理，其他证书类型的默认显示宽度与其有符号数的最小值的宽度相同。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int2(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT(5),</span><br><span class="line">f3 INT(5) ZEROFILL</span><br><span class="line">)</span><br><span class="line">DESC test_int2;</span><br><span class="line">INSERT INTO test_int2(f1,f2,f3)</span><br><span class="line">VALUES(1,123,123);</span><br><span class="line">INSERT INTO test_int2(f1,f2)</span><br><span class="line">VALUES(123456,123456);</span><br><span class="line">INSERT INTO test_int2(f1,f2,f3)</span><br><span class="line">VALUES(123456,123456,123456);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_int2;</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">| f1 | f2 | f3 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">| 1 | 123 | 00123 |</span><br><span class="line">| 123456 | 123456 | NULL |</span><br><span class="line">| 123456 | 123456 | 123456 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="222unsigned"><a class="markdownIt-Anchor" href="#222unsigned"></a> 2.2.2UNSIGNED</h5>
<p>UNSIGNED：无符号类型（非负），所有的类型都有一个可选的属性UNSIGNED（无符号属性），无符号类型的最小取值为0。所以如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p>
<p>int类型默认显示宽度为int（11），无符号int类型默认显示宽度为int（10）.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int3(</span><br><span class="line">f1 INT UNSIGNED</span><br><span class="line">);</span><br><span class="line">mysql&gt; desc test_int3;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| f1 | int(10) unsigned | YES | | NULL | |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="223zerofill"><a class="markdownIt-Anchor" href="#223zerofill"></a> 2.2.3ZEROFILL</h5>
<p>ZEROFILL:0填充，（如果某列时ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果制定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p>
<p>原来，在int（M）中，M的值跟int（M）所占多少存储空间并无任何关系。int(3)、int(4)、int(8)在磁盘上都是占用4bytes的存储空间。也就是说， <strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。</strong> 如果整数超过M位，就按照实际位数存储。只是无需再用字符0进行填充。</p>
<h4 id="23使用场景"><a class="markdownIt-Anchor" href="#23使用场景"></a> 2.3使用场景</h4>
<p>TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p>
<p>SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p>
<p>MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。</p>
<p>INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p>
<p>BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证 券公司衍生产品持仓等。</p>
<h4 id="24如何选择"><a class="markdownIt-Anchor" href="#24如何选择"></a> 2.4如何选择？</h4>
<p>在评估用哪种整数类型的时候，你需要考虑<strong>存储空间</strong>和<strong>可靠性</strong>的平衡问题：一方面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的帧数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<strong>系统错误</strong>，影响可靠性。</p>
<p>举个例子，商品编号采用的数据类型是INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p>
<p>如果使用SMALLINT类型，虽然占用字节数比INT类型的整数少，但是却不能保证数据不会超出范围65535.相反，使用INT，就能确保有足够大的取值范围，不用担心数据超出范围印象可靠性问题。</p>
<p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先保存数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p>
<h3 id="3浮点类型"><a class="markdownIt-Anchor" href="#3浮点类型"></a> 3.浮点类型</h3>
<h4 id="31类型介绍"><a class="markdownIt-Anchor" href="#31类型介绍"></a> 3.1类型介绍</h4>
<p>浮点数和定点数类型的特点是可以<strong>处理小数</strong>，你可以把整数堪称小数的一个特例。因此浮点数和定点数的使用场景，比整数大多了。MySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。</p>
<ul>
<li>FLOAT表示单精度浮点数；</li>
<li>DOUBLE表示双精度浮点数；</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_11-00-59.png"
                        alt="" 
                 ></p>
<ul>
<li>REAL默认就是DOUBLE。如果你把SQL模式设定为启用“REAL_AS_FLOAT”，那么，MySQL就认为REAL是FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下SQL语句实现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET sql_mode = &quot;REAL_AS_FLOAT&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题1：FLOAT和DOUBLE这两种数据类型的区别是啥呢？</p>
<p>FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围也大。</p>
<p>问题2：为什么浮点数类型的无符号数取值范围只相当于有符号取值范围的一半，也就是只相当于有符号取值范围大于等于零的部分？</p>
<p>MySQL存储浮点数的格式为：符号(S)、尾数(M)和阶码(E)。因此无论有没有符号，MySQL的浮点数都会存储表示符号的部分。因此，所谓的无符号取值范围，其实就是有符号取值范围大于等于零的部分。</p>
<h4 id="32数据精度说明"><a class="markdownIt-Anchor" href="#32数据精度说明"></a> 3.2数据精度说明</h4>
<p>对于浮点类型，在MySQL中简单精度值使用4个字节，双精度使用8个字节。</p>
<ul>
<li>MySQL允许使用非法标准语法(其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用)：FLOAT(M,D)或  DOUBLE(M,D) 。这里，M称为 精度 ，D称为 标度 。(M,D)中 M=整数位+小数 位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。</li>
<li>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示。</li>
<li>说明：浮点类型，也可以加 UNSIGNED ，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围。</li>
<li>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：
<ul>
<li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li>
<li>如果存储时，小数点部分若超出范围，就分以下情况：
<ul>
<li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li>
<li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。</li>
</ul>
</li>
</ul>
</li>
<li>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可 能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</li>
</ul>
<h4 id="33精度误差说明"><a class="markdownIt-Anchor" href="#33精度误差说明"></a> 3.3精度误差说明</h4>
<p>浮点护士类型有个缺陷，就是不精准。下面我来重点解释一下为什么MySQL的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47，0.44，0.19，我们期待的运行结果是：0.47+0.44+0.19 = 1.1。而使用sum之后查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_double2(</span><br><span class="line">f1 DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO test_double2</span><br><span class="line">VALUES(0.47),(0.44),(0.19);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1)</span><br><span class="line">-&gt; FROM test_double2;</span><br><span class="line">+--------------------+</span><br><span class="line">| SUM(f1) |</span><br><span class="line">+--------------------+</span><br><span class="line">| 1.0999999999999999 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型 改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p>
<p>那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。</p>
<p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二 进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如 果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。</p>
<p>在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数 类型： DECIMAL 。</p>
<h3 id="4定点数类型"><a class="markdownIt-Anchor" href="#4定点数类型"></a> 4.定点数类型</h3>
<h4 id="41类型介绍"><a class="markdownIt-Anchor" href="#41类型介绍"></a> 4.1类型介绍</h4>
<ul>
<li>MySQL中的定点数类型中只有DECIMAL一种类型。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_11-51-30.png"
                        alt="" 
                 ></p>
<p>​	使用DECIMAL(M,D)的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65,0&lt;=D&lt;=30,D&lt;M。例如，定义DECIMAL（5，2）类型，表示该列取值范围是 -999.99~999.99。</p>
<ul>
<li><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是 说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可 以更大一些。</li>
<li>定点数在MySQL内部是以 <strong>字符串</strong> 的形式进行存储，这就决定了它一定是精准的。</li>
<li>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的 精度范围时，则MySQL同样会进行四舍五入处理。</li>
<li><strong>浮点数VS定点数</strong>
<ul>
<li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用 于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动 力学等）</li>
<li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉 及金额计算的场景）</li>
</ul>
</li>
</ul>
<h4 id="42开发中的经验"><a class="markdownIt-Anchor" href="#42开发中的经验"></a> 4.2开发中的经验</h4>
<blockquote>
<p>“由于DECIMAL数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都是用DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。”</p>
</blockquote>
<h3 id="5位类型bit"><a class="markdownIt-Anchor" href="#5位类型bit"></a> 5.位类型：BIT</h3>
<p>BIT类型中存储的是二进制值，类似010110.</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_15-44-41.png"
                        alt="" 
                 ></p>
<p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存储1位二进制的值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p>
<h3 id="6日期与时间"><a class="markdownIt-Anchor" href="#6日期与时间"></a> 6.日期与时间</h3>
<p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p>
<p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p>
<ul>
<li>YEAR类型通常用来表示年</li>
<li>DATE类型通常用来表示年月日</li>
<li>TIME类型通常用来表示时分秒</li>
<li>DATETIME类型通常用来表示年月日时分秒</li>
<li>TIMESTAMP类型通常用来表示带时区的年月日时分秒</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_15-54-39.png"
                        alt="" 
                 ></p>
<p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p>
<p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表 示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p>
<h4 id="61year类型"><a class="markdownIt-Anchor" href="#61year类型"></a> 6.1YEAR类型</h4>
<p>YEAR类型用来表示年份，在所有的日期时间类型中占用的存储空间最小，只需要1个字节的存储空间。</p>
<p>在MySQL中，YEAR有以下几种存储格式：</p>
<ul>
<li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155.</li>
<li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99.
<ul>
<li>当取值为01到69时，表示2001到2069；</li>
<li>当取值为70到99时，表示1970到1999；</li>
<li>当取值整数的0或00添加的话，那么是0000年；</li>
<li>当取值是日期/字符串的‘0’添加的话，是2000年；</li>
</ul>
</li>
</ul>
<p>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL8开始，不推荐使用指定显示宽度的YEAR(4)数据类型</p>
<h4 id="62date类型"><a class="markdownIt-Anchor" href="#62date类型"></a> 6.2DATE类型</h4>
<p>DATE类型表示日期，没有时间部分，格式为YYYY-MM-DD，其中，YYYY表示年份，MM表示月份，DD表示日期。需要3个字节的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<ul>
<li>以YYYY-MM-DD格式或者YYYYMMDD格式表示的日期字符串， 其最小取值为1000-01-01，最大取值为 9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li>
<li>以YY-MM-DD格式或者YYMMDD格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的的格式条件为：当年分取值为00到69时，会被转换为2000到2069；当年份取值为70到99时，会被转化为1970到1999.</li>
<li>使用CURRENT_DATE()或者NOW()函数，会插入当前系统的日期。</li>
</ul>
<h4 id="63time类型"><a class="markdownIt-Anchor" href="#63time类型"></a> 6.3TIME类型</h4>
<p>TIME类型用来表示时间，不包括日期部分。在MySQL中，需要3个字节的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在MySQL中，向TIME类型的字段插入数据时，也可以使用集中不同的格式。</p>
<ol>
<li>可以使用带有冒号的字符串， 比如’ D HH:MM:SS’ 、’ HH:MM:SS ‘、’ HH:MM ‘、’ D HH:MM ‘、’ D HH ‘或’ SS '格式，都能被正 确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串 插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串 表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。</li>
<li>可以使用不带有冒号的 字符串或者数字，格式为’ HHMMSS '或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存 储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示 00:12:10，而不是12:10:00。</li>
<li>使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。</li>
</ol>
<h4 id="64datetime类型"><a class="markdownIt-Anchor" href="#64datetime类型"></a> 6.4DATETIME类型</h4>
<p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要8个字节的村出空间。在格式上为DATE类型和TIME类型的组合，可以表示为YYYY-MM-DD HH:MM:SS，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<ul>
<li>以YYYY-MM-DD HH:MM:SS格式或者YYYYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00 ，最大值为9999-12-03 23:59:59。
<ul>
<li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li>
</ul>
</li>
<li>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位 数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</li>
<li>使用函数 CURRENT_TIMESTAMP() 和 NOW() ，可以向DATETIME类型的字段插入系统的当前日期和 时间。</li>
</ul>
<h4 id="65-timestamp类型"><a class="markdownIt-Anchor" href="#65-timestamp类型"></a> 6.5  TIMESTAMP类型</h4>
<p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS ，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储 “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫 作世界标准时间。</p>
<ul>
<li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时 区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li>
</ul>
<p><strong>TIMESTAMP和DATETIME的区别：</strong></p>
<ul>
<li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li>
<li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li>
<li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li>
<li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能 反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</li>
</ul>
<h4 id="66开发中的经验"><a class="markdownIt-Anchor" href="#66开发中的经验"></a> 6.6开发中的经验</h4>
<blockquote>
<p>用的最多的日期时间类型，就是DATETIME。 虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、 DATE（日期）， 以及TIMESTAMP类型，但是在实际项目中，尽量用DATETIME类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也是最大，使用起来比较方便。毕竟，日期时间i西南西分散在好几个字段，很不容易记，而且查询的时候，SQL语句语句也会更急复杂。</p>
<p>此外，一般注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用时间戳，因为DATETIME虽然直观，但不便于计算。</p>
</blockquote>
<h3 id="7文本字符串类型"><a class="markdownIt-Anchor" href="#7文本字符串类型"></a> 7.文本字符串类型</h3>
<p>在实际的项目开发中，我们还经常遇到一种数据，就是字符串数据。</p>
<p>MySQL中，文本字符串总体上分为CHAR、VARCHAR  、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、 LONGTEXT 、 ENUM 、 SET 等类型。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_17-22-15.png"
                        alt="" 
                 ></p>
<h4 id="71char与varchar类型"><a class="markdownIt-Anchor" href="#71char与varchar类型"></a> 7.1CHAR与VARCHAR类型</h4>
<p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_17-24-12.png"
                        alt="" 
                 ></p>
<p><strong>CHAR类型：</strong></p>
<ul>
<li>CHAR(M)类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li>
<li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在右侧填充空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li>
<li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li>
</ul>
<p><strong>VARCHAR类型：</strong></p>
<ul>
<li>VARCHAR(M)定义时，必须指定长度M,否则报错。</li>
<li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</li>
</ul>
<p><strong>哪些情况使用CHAR或VARCHAR更好</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_17-32-21.png"
                        alt="" 
                 ></p>
<p>情况1： 存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个 byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p>
<p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据 长度的特性就消失了，而且还要占个长度信息。</p>
<p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个 非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p>
<p>情况4：具体存储引擎中的情况：</p>
<ul>
<li>MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长 度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。</li>
<li>MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用 CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</li>
<li>InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区 分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素 是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的， 其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li>
</ul>
<h4 id="72text类型"><a class="markdownIt-Anchor" href="#72text类型"></a> 7.2TEXT类型</h4>
<p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4中类型， 分别为TINYTEXT、TEXT、 MEDIUMTEXT 和 LONGTEXT 类型。</p>
<p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p>
<p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-07_17-46-21.png"
                        alt="" 
                 >**由于实际存储的长度不确定，MySQL不允许TEXT类型的字段做主键。**遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_text(</span><br><span class="line">tx TEXT</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_text</span><br><span class="line">VALUES(&#x27;atguigu &#x27;);</span><br><span class="line">SELECT CHAR_LENGTH(tx)</span><br><span class="line">FROM test_text; #10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p>
<p><strong>开发中的经验：</strong></p>
<blockquote>
<p>TEXT文本类型，可以存在较大的文本段，搜索速度稍微慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替，还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独使用一个表。</p>
</blockquote>
<h3 id="8enum类型"><a class="markdownIt-Anchor" href="#8enum类型"></a> 8.ENUM类型</h3>
<p>ENUM类型也叫做枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p>
<p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_09-05-13.png"
                        alt="" 
                 ></p>
<ul>
<li>当ENUM类型包含1~255个成员时，需要1个字节的存储空间；</li>
<li>当ENUM类型包含256~65535个成员时，需要2个字节的存储空间。</li>
<li>ENUM类型的成员个数的上限为 65535个。</li>
</ul>
<h3 id="9set类型"><a class="markdownIt-Anchor" href="#9set类型"></a> 9.SET类型</h3>
<p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数上限为64.设置字段值时，可以取取值范围内的0个或者多个值。</p>
<p>当SET类型包含包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_09-29-04.png"
                        alt="" 
                 ></p>
<p>SET类型存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p>
<h3 id="10二进制字符串类型"><a class="markdownIt-Anchor" href="#10二进制字符串类型"></a> 10.二进制字符串类型</h3>
<p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p>
<p>MySQL中支持二进制字符串主要包括 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p>
<p><strong>BINARY与VARBINARY类型</strong></p>
<p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p>
<p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未 指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字 节，将在右边填充’\0’以补齐指定长度。</p>
<p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长 度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个 字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_09-35-36.png"
                        alt="" 
                 ></p>
<p><strong>BLOB类型</strong></p>
<p>BLOB是一个二进制大对象，可以容纳可变数量的数据。</p>
<p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大 长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。</p>
<blockquote>
<p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中。</p>
</blockquote>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_09-38-07.png"
                        alt="" 
                 ></p>
<p><strong>TEXT和BLOB的使用注意事项：</strong></p>
<p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p>
<ol>
<li>BLOB和TEXT值也会引起自己的一些问题，特别时执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的“空洞”，以后填入这些“空洞”的记录可能长度不同。为了提高性能，建议定期使用OPTIMIZE TABLE功能对这类表进行碎片整理。</li>
<li>如果需要对大文本字段进行模糊查询，MySQL提供了前缀索引。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的的在网络上传输大量的值。</li>
<li>把BLOB或TEXT列<strong>分离到单独的表</strong>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使得你在主数据表上运行SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</li>
</ol>
<h3 id="11json类型"><a class="markdownIt-Anchor" href="#11json类型"></a> 11.JSON类型</h3>
<p>JSON是一种轻量级的数据交换格式。简洁和清新的层次结构使得JSON成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON可以将JavaScript对象中表示的一组数据转换为字符串，然后就可以在网络或程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p>
<p>在MySQL5.7中，就已经支持JSON数据格式。在MySQL8版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。创建数据表，表中包含一个JSON类型的字段js。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_json(</span><br><span class="line">js json</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向表中插入JSON数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_json (js)</span><br><span class="line">VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,</span><br><span class="line">&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">-&gt; FROM test_json;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT js -&gt; &#x27;$.name&#x27; AS NAME,js -&gt; &#x27;$.age&#x27; AS age ,js -&gt; &#x27;$.address.province&#x27;</span><br><span class="line">AS province, js -&gt; &#x27;$.address.city&#x27; AS city</span><br><span class="line">-&gt; FROM test_json;</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">| NAME | age | province | city |</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">| &quot;songhk&quot; | 18 | &quot;beijing&quot; | &quot;beijing&quot; |</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。</p>
<h3 id="12空间类型"><a class="markdownIt-Anchor" href="#12空间类型"></a> 12.空间类型</h3>
<p>MySQL空间类型拓展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用Geometry（几何）来表示所有地理特征。Geometry指一个电或点的集合，代表世界上任何具有位置的事物。</p>
<p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、 LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION 。</p>
<ul>
<li>Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的 子类。
<ul>
<li>Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)， 坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。</li>
<li>LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的 （simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。</li>
<li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最 简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。</li>
</ul>
</li>
</ul>
<p>下面展示几种常见的集合图形元素：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_10-15-14.png"
                        alt="" 
                 ></p>
<p>下面展示的是多个同类或异类几何图形元素的组合：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_10-20-58.png"
                        alt="" 
                 ></p>
<h3 id="13小结及选择建议"><a class="markdownIt-Anchor" href="#13小结及选择建议"></a> 13.小结及选择建议</h3>
<p>在定义数据类型时，如果确定是整数，就用INT；如果是小数，一定用顶点数类型DECIMAL(M,D) ； 如果是日期与时间，就用 DATETIME 。</p>
<p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两方面的，可靠性好，并不意味着高效。比如，TEXT虽然使用方便，但是效率不如CHAR(M)和VARCHAR(M)。</p>
<p>关于字符串的选择，建议参考如下阿里巴巴《Java开发手册》规范：</p>
<p><strong>阿里巴巴《Java开发手册》之MySQL数据库</strong></p>
<ul>
<li>任何字段如果为非负数，必须是UNSIGNED</li>
<li>【 强制 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。
<ul>
<li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得 到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。</li>
</ul>
</li>
<li>【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</li>
<li>【 强制 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大 于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li>
</ul>
<h2 id="十三-约束"><a class="markdownIt-Anchor" href="#十三-约束"></a> 十三、约束</h2>
<h3 id="1约束概述"><a class="markdownIt-Anchor" href="#1约束概述"></a> 1.约束概述</h3>
<h4 id="11为什么需要约束"><a class="markdownIt-Anchor" href="#11为什么需要约束"></a> 1.1为什么需要约束</h4>
<p>数据完整性是指数据的精确性可靠性。防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p>
<p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>从以下四个方面考虑：</p>
<ul>
<li>实体完整性：例如，同一个表中，不能存在两条完全相同无法区分的记录</li>
<li>域完整性：例如：年龄范围0-120，性别范围“男/女”</li>
<li>引用完整性：例如：员工所在部门，在部门表中要能找到这个部门</li>
<li>用户自定义完整性：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li>
</ul>
<h4 id="12什么是约束"><a class="markdownIt-Anchor" href="#12什么是约束"></a> 1.2什么是约束</h4>
<p>约束时表级的强制规定。</p>
<p>可以在<strong>创建表时规定约束（通过 CREATE TABLE TABLE 语句）</strong>，或者在<strong>表创建之后通过ALTER TABLE 语句规定约束</strong></p>
<h4 id="13约束的分类"><a class="markdownIt-Anchor" href="#13约束的分类"></a> 1.3约束的分类</h4>
<ul>
<li>根据约束数据列的限制，约束可分为：
<ul>
<li>单列约束：每个约束只约束一列</li>
<li>多列约束：每个约束可约束多列数据</li>
</ul>
</li>
<li>根据约束的作用范围，约束可分为：
<ul>
<li>列级约束：只能作用在一个列上，跟在列的定义后面</li>
<li>表级约束：可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			位置 支持的约束类型 是否可以起约束名</span><br><span class="line">列级约束： 列的后面 语法都支持，但外键没有效果 不可以</span><br><span class="line">表级约束： 所有列的下面 默认和非空不支持，其他支持 可以（主键没有效果）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>根据约束起的作用，约束可分为：
<ul>
<li>NOT NULL 非空约束，规定某个字段不能为空</li>
<li>UNIQUE 唯一约束，规定某个字段在整个表中是唯一的</li>
<li>PRIMARY KEY 主键(非空且唯一)约束</li>
<li>FOREIGN KEY 外键约束</li>
<li>CHECK 检查约束</li>
<li>DEFAULT 默认值约束</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</p>
</blockquote>
<ul>
<li>查看某个表已有的约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#information_schema数据库名（系统库）</span><br><span class="line">#table_constraints表名称（专门存储各个表的约束）</span><br><span class="line">SELECT * FROM information_schema.table_constraints</span><br><span class="line">WHERE table_name = &#x27;表名称&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2非空约束"><a class="markdownIt-Anchor" href="#2非空约束"></a> 2.非空约束</h3>
<h4 id="21作用"><a class="markdownIt-Anchor" href="#21作用"></a> 2.1作用</h4>
<p>限定某个字段/某列的值不允许为空</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-08_10-50-46.png"
                        alt="" 
                 ></p>
<h4 id="22关键字"><a class="markdownIt-Anchor" href="#22关键字"></a> 2.2关键字</h4>
<p>NOT NULL</p>
<h4 id="23特点"><a class="markdownIt-Anchor" href="#23特点"></a> 2.3特点</h4>
<ul>
<li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li>
<li>非空约束只能出现在表对象的列上，只能，讴歌列单独限定非空，不能组合非空</li>
<li>一个表可以有很多列都分别限定了非空</li>
<li>空字符串‘’不等于NULL，0也不等于NULL</li>
</ul>
<h4 id="24添加非空约束"><a class="markdownIt-Anchor" href="#24添加非空约束"></a> 2.4添加非空约束</h4>
<ul>
<li>建表时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 NOT NULL,</span><br><span class="line">字段名 数据类型 NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>建表后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 not null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="25删除非空约束"><a class="markdownIt-Anchor" href="#25删除非空约束"></a> 2.5删除非空约束</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line">或</span><br><span class="line">alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-唯一性约束"><a class="markdownIt-Anchor" href="#3-唯一性约束"></a> 3. 唯一性约束</h3>
<h4 id="31作用"><a class="markdownIt-Anchor" href="#31作用"></a> 3.1作用</h4>
<p>用来限制某个字段/某列的值不能重复。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_09-49-48.png"
                        alt="" 
                 ></p>
<h4 id="32关键字"><a class="markdownIt-Anchor" href="#32关键字"></a> 3.2关键字</h4>
<p>UNIQUE</p>
<h4 id="33特点"><a class="markdownIt-Anchor" href="#33特点"></a> 3.3特点</h4>
<ul>
<li>同一个表可以有多个唯一约束</li>
<li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li>
<li>唯一性约束允许列值为空。</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li>
<li>MySQL会给唯一约束的列上默认创建一个唯一索引。</li>
</ul>
<h4 id="34添加唯一约束"><a class="markdownIt-Anchor" href="#34添加唯一约束"></a> 3.4添加唯一约束</h4>
<ul>
<li>建表时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 unique,</span><br><span class="line">字段名 数据类型 unique key,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[constraint 约束名] unique key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>建表后指定唯一键约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯</span><br><span class="line">一的</span><br><span class="line">#方式1：</span><br><span class="line">alter table 表名称 add unique key(字段列表);</span><br><span class="line"></span><br><span class="line">#方式2：</span><br><span class="line">alter table 表名称 modify 字段名 字段类型 unique;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="35关于复合唯一约束"><a class="markdownIt-Anchor" href="#35关于复合唯一约束"></a> 3.5关于复合唯一约束</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多</span><br><span class="line">个字段的组合是唯一的</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#学生表</span><br><span class="line">create table student(</span><br><span class="line">sid int, #学号</span><br><span class="line">sname varchar(20), #姓名</span><br><span class="line">tel char(11) unique key, #电话</span><br><span class="line">cardid char(18) unique key #身份证号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#课程表</span><br><span class="line">create table course(</span><br><span class="line">cid int, #课程编号</span><br><span class="line">cname varchar(20) #课程名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#选课表</span><br><span class="line">create table student_course(</span><br><span class="line">id int,</span><br><span class="line">sid int,</span><br><span class="line">cid int,</span><br><span class="line">score int,</span><br><span class="line">unique key(sid,cid) #复合唯一</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);#成功</span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);#成功</span><br><span class="line">insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);#成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">| sid | sname | tel | cardid |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">| 1 | 张三 | 13710011002 | 101223199012015623 |</span><br><span class="line">| 2 | 李四 | 13710011003 | 101223199012015624 |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+------+-------+</span><br><span class="line">| cid | cname |</span><br><span class="line">+------+-------+</span><br><span class="line">| 1001 | Java |</span><br><span class="line">| 1002 | MySQL |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values</span><br><span class="line">(1, 1, 1001, 89),</span><br><span class="line">(2, 1, 1002, 90),</span><br><span class="line">(3, 2, 1001, 88),</span><br><span class="line">(4, 2, 1002, 56);#成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student_course;</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">| id | sid | cid | score |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">| 1 | 1 | 1001 | 89 |</span><br><span class="line">| 2 | 1 | 1002 | 90 |</span><br><span class="line">| 3 | 2 | 1001 | 88 |</span><br><span class="line">| 4 | 2 | 1002 | 56 |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values (5, 1, 1001, 88);#失败</span><br><span class="line">#ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;sid&#x27; 违反sid-cid的复合唯一</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="35删除唯一约束"><a class="markdownIt-Anchor" href="#35删除唯一约束"></a> 3.5删除唯一约束</h4>
<ul>
<li>添加唯一性约束的列上也会自动创建唯一索引。</li>
<li>删除唯一约束只能通过删除唯一索引的方式删除。</li>
<li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li>
<li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER</span><br><span class="line">DROP INDEX uk_name_pwd;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以通过show index from 表名称；查看表的索引</p>
</blockquote>
<h3 id="4primary-key约束"><a class="markdownIt-Anchor" href="#4primary-key约束"></a> 4.PRIMARY KEY约束</h3>
<h4 id="41作用"><a class="markdownIt-Anchor" href="#41作用"></a> 4.1作用</h4>
<p>用来唯一标识表中的一行记录。</p>
<h4 id="42关键字"><a class="markdownIt-Anchor" href="#42关键字"></a> 4.2关键字</h4>
<p>primary key</p>
<h4 id="43特点"><a class="markdownIt-Anchor" href="#43特点"></a> 4.3特点</h4>
<ul>
<li>逐渐约束相当于<strong>唯一约束+非空约束的组合</strong>，主键约束列不允许重复出现，也不允许出现空值。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_10-49-43.png"
                        alt="" 
                 ></p>
<ul>
<li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li>
<li>主键约束对应着表中的一列或者多列（复合主键）</li>
<li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li>
<li>MySQL的主键总是PRIMARY，就算自己命名了主键约束名也没用。</li>
<li>当创建主键约束时，系统默认会在所在的列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键对应的索引就自动删除了。</li>
<li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li>
</ul>
<h4 id="44添加主键约束"><a class="markdownIt-Anchor" href="#44添加主键约束"></a> 4.4添加主键约束</h4>
<ul>
<li>建表时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型 primary key, #列级模式</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[constraint 约束名] primary key(字段名) #表级模式</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>建表之后增加主键约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="45关于复合主键"><a class="markdownIt-Anchor" href="#45关于复合主键"></a> 4.5关于复合主键</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#学生表</span><br><span class="line">create table student(</span><br><span class="line">sid int primary key, #学号</span><br><span class="line">sname varchar(20) #学生姓名</span><br><span class="line">);</span><br><span class="line">#课程表</span><br><span class="line">create table course(</span><br><span class="line">cid int primary key, #课程编号</span><br><span class="line">cname varchar(20) #课程名称</span><br><span class="line">);</span><br><span class="line">#选课表</span><br><span class="line">create table student_course(</span><br><span class="line">sid int,</span><br><span class="line">cid int,</span><br><span class="line">score int,</span><br><span class="line">primary key(sid,cid) #复合主键</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;),(2,&#x27;李四&#x27;);</span><br><span class="line">insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+</span><br><span class="line">| sid | sname |</span><br><span class="line">+-----+-------+</span><br><span class="line">| 1 | 张三 |</span><br><span class="line">| 2 | 李四 |</span><br><span class="line">+-----+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+------+-------+</span><br><span class="line">| cid | cname |</span><br><span class="line">+------+-------+</span><br><span class="line">| 1001 | Java |</span><br><span class="line">| 1002 | MySQL |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student_course;</span><br><span class="line">+-----+------+-------+</span><br><span class="line">| sid | cid | score |</span><br><span class="line">+-----+------+-------+</span><br><span class="line">| 1 | 1001 | 89 |</span><br><span class="line">| 1 | 1002 | 90 |</span><br><span class="line">| 2 | 1001 | 88 |</span><br><span class="line">| 2 | 1002 | 56 |</span><br><span class="line">+-----+------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values(1, 1001, 100);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line">mysql&gt; desc student_course;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| sid | int(11) | NO | PRI | NULL | |</span><br><span class="line">| cid | int(11) | NO | PRI | NULL | |</span><br><span class="line">| score | int(11) | YES | | NULL | |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="46删除主键约束"><a class="markdownIt-Anchor" href="#46删除主键约束"></a> 4.6删除主键约束</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 drop primary key;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
</blockquote>
<h3 id="5自增列auto_increment"><a class="markdownIt-Anchor" href="#5自增列auto_increment"></a> 5.自增列：AUTO_INCREMENT</h3>
<h4 id="51作用"><a class="markdownIt-Anchor" href="#51作用"></a> 5.1作用</h4>
<p>某个字段的值自增</p>
<h4 id="52关键字"><a class="markdownIt-Anchor" href="#52关键字"></a> 5.2关键字</h4>
<p>auto_increment</p>
<h4 id="53特点和要求"><a class="markdownIt-Anchor" href="#53特点和要求"></a> 5.3特点和要求</h4>
<ol>
<li>一个表最多只能有一个自增长列</li>
<li>当需要产生唯一标识符或顺序时，可设置自增长</li>
<li>自增长列约束的列必须是键列（主键列，唯一键列）</li>
<li>自增约束的列的数据类型必须是整数类型</li>
<li>如果自增列制定了0和null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li>
</ol>
<h4 id="54如何指定自增约束"><a class="markdownIt-Anchor" href="#54如何指定自增约束"></a> 5.4如何指定自增约束</h4>
<ul>
<li>建表时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型 primary key auto_increment,</span><br><span class="line">字段名 数据类型 unique key not null,</span><br><span class="line">字段名 数据类型 unique key,</span><br><span class="line">字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型 default 默认值 ,</span><br><span class="line">字段名 数据类型 unique key auto_increment,</span><br><span class="line">字段名 数据类型 not null default 默认值,,</span><br><span class="line">primary key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key auto_increment,</span><br><span class="line">ename varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| eid | int(11) | NO | PRI | NULL | auto_increment |</span><br><span class="line">| ename | varchar(20) | YES | | NULL | |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>建表后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 auto_increment;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="55如何删除自增约束"><a class="markdownIt-Anchor" href="#55如何删除自增约束"></a> 5.5如何删除自增约束</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束</span><br><span class="line">alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify eid int;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid | int(11) | NO | PRI | NULL | |</span><br><span class="line">| ename | varchar(20) | YES | | NULL | |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="56mysql8新特性-自增变量的持久化"><a class="markdownIt-Anchor" href="#56mysql8新特性-自增变量的持久化"></a> 5.6MySQL8新特性-自增变量的持久化</h4>
<p>在MySQL8之前，自增主键AUTO_INCREMENT的值如果大于 max(primary key)+1，在MySQL重启后，会重 置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发 现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如 下： 创建的数据表中包含自增主键的id字段，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插入4个空值，执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1</span><br><span class="line">VALUES(0),(0),(0),(0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询数据表test1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 1 |</span><br><span class="line">| 2 |</span><br><span class="line">| 3 |</span><br><span class="line">| 4 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除id为4的记录，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 WHERE id = 4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次插入一个空值，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1 VALUES(0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询此时数据表test1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 1 |</span><br><span class="line">| 2 |</span><br><span class="line">| 3 |</span><br><span class="line">| 5 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5.删除id为5的记录，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 where id=5;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启数据库，重新插入一个空值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1 values(0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次查询数据表test1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 1 |</span><br><span class="line">| 2 |</span><br><span class="line">| 3 |</span><br><span class="line">| 4 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。在MySQL5.7系统中，对于自增主键的分配规则， 是由InnoDB数据字典 内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。</p>
<p>在MySQL 8.0版本中，上述测试步骤最后一步的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 1 |</span><br><span class="line">| 2 |</span><br><span class="line">| 3 |</span><br><span class="line">| 6 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，自增变量已经持久化了。</p>
<p>MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志 中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p>
<h3 id="6外键约束"><a class="markdownIt-Anchor" href="#6外键约束"></a> 6.外键约束</h3>
<h4 id="610阿里开发规范"><a class="markdownIt-Anchor" href="#610阿里开发规范"></a> 6.10阿里开发规范</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。</span><br><span class="line">说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响数据库的 插入速度 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7check约束"><a class="markdownIt-Anchor" href="#7check约束"></a> 7.CHECK约束</h3>
<h4 id="71作用"><a class="markdownIt-Anchor" href="#71作用"></a> 7.1作用</h4>
<p>检查某个字段的值是否符合XX要求，一般指的是值的范围</p>
<h4 id="72关键字"><a class="markdownIt-Anchor" href="#72关键字"></a> 7.2关键字</h4>
<p>CHECK</p>
<h4 id="73说明mysql57不支持"><a class="markdownIt-Anchor" href="#73说明mysql57不支持"></a> 7.3说明：MySQL5.7不支持</h4>
<p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警 告 但是MySQL 8.0中可以使用check约束了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">ename varchar(5),</span><br><span class="line">gender char check (&#x27;男&#x27; or &#x27;女&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee values(1,&#x27;张三&#x27;,&#x27;妖&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | gender |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| 1 | 张三 | 妖 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">age INT CHECK(age &gt; 20),</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age tinyint check(age &gt;20) 或 sex char(2) check(sex in(‘男’,’女’))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECK(height&gt;=0 AND height&lt;3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8default约束"><a class="markdownIt-Anchor" href="#8default约束"></a> 8.DEFAULT约束</h3>
<h4 id="81作用"><a class="markdownIt-Anchor" href="#81作用"></a> 8.1作用</h4>
<p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默 认值。</p>
<h4 id="82关键字"><a class="markdownIt-Anchor" href="#82关键字"></a> 8.2关键字</h4>
<p>DEFAULT</p>
<h4 id="83如何给字段加默认值"><a class="markdownIt-Anchor" href="#83如何给字段加默认值"></a> 8.3如何给字段加默认值</h4>
<ul>
<li>建表时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型 primary key,</span><br><span class="line">字段名 数据类型 unique key not null,</span><br><span class="line">字段名 数据类型 unique key,</span><br><span class="line">字段名 数据类型 not null default 默认值,</span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名 数据类型 default 默认值 ,</span><br><span class="line">字段名 数据类型 not null default 默认值,</span><br><span class="line">字段名 数据类型 not null default 默认值,</span><br><span class="line">primary key(字段名),</span><br><span class="line">unique key(字段名)</span><br><span class="line">);</span><br><span class="line">说明：默认值约束一般不在唯一键和主键列上加</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">ename varchar(20) not null,</span><br><span class="line">gender char default &#x27;男&#x27;,</span><br><span class="line">tel char(11) not null default &#x27;&#x27; #默认是空字符串</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>建表后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值;</span><br><span class="line">#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了</span><br><span class="line">#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了</span><br><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值 not null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">ename varchar(20),</span><br><span class="line">gender char,</span><br><span class="line">tel char(11) not null</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="84如何删除默认值约束"><a class="markdownIt-Anchor" href="#84如何删除默认值约束"></a> 8.4如何删除默认值约束</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br><span class="line">alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除</span><br><span class="line">alter table employee modify tel char(11) not null;#删除tel字段默认值约束，保留非空约束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9面试"><a class="markdownIt-Anchor" href="#9面试"></a> 9.面试</h3>
<blockquote>
<p>面试1、为什么建表时，加not null default 或 default 0</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不想让表中出现null值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试2、为什么不想要null值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</span><br><span class="line">效率不高。影响提高索引效果。因此，我们往往在建表时 not null default &#x27;&#x27; 或 default 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在MySQL中，默认AUTO_INCREMENT的初始</span><br><span class="line">值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试4、并不是每个表都可以任意选择存储引擎？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外键约束（FOREIGN KEY）不能跨引擎使用。</span><br><span class="line">MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十四-视图"><a class="markdownIt-Anchor" href="#十四-视图"></a> 十四、视图</h2>
<h3 id="1常见的数据库对象"><a class="markdownIt-Anchor" href="#1常见的数据库对象"></a> 1.常见的数据库对象</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_13-27-34.png"
                        alt="" 
                 ></p>
<h3 id="2视图概述"><a class="markdownIt-Anchor" href="#2视图概述"></a> 2.视图概述</h3>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_13-31-11.png"
                        alt="" 
                 ></p>
<h4 id="21为什么使用视图"><a class="markdownIt-Anchor" href="#21为什么使用视图"></a> 2.1为什么使用视图？</h4>
<p>视图一方面可以帮助我们使用表的一部分而不是所有表，另一方面也可以针对不同用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他，再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中那个则不提供这个字段。</p>
<p>刚才讲的只是视图的一个使用该场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p>
<h4 id="22视图的理解"><a class="markdownIt-Anchor" href="#22视图的理解"></a> 2.2视图的理解</h4>
<ul>
<li>视图是一种虚拟表，本身是不具有数据的，占有很少的内存空间，它是SQL中的一个重要概念。</li>
<li>视图建立在已有表的基础上，视图赖以建立的这些表称为基表。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_13-40-51.png"
                        alt="" 
                 ></p>
<ul>
<li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li>
<li>向视图提供数据内容地语句为SELECT语句，可以将视图理解为存储起来地SELECT语句
<ul>
<li>在数据库中，视图不会保存数据，数据真正保存在数据表中，当视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；繁殖亦然。</li>
</ul>
</li>
<li>视图，是向用户提供基表数据地另一种表现形式。通常情况下，小型项目的数据库可以不使用视 图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我 们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li>
</ul>
<h3 id="3创建视图"><a class="markdownIt-Anchor" href="#3创建视图"></a> 3.创建视图</h3>
<ul>
<li>在CREATE VIEW 语句中嵌入子查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE]</span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW 视图名称 [(字段列表)]</span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>精简版</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名称</span><br><span class="line">AS 查询语句</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="31创建单表视图"><a class="markdownIt-Anchor" href="#31创建单表视图"></a> 3.1创建单表视图</h4>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM salvu80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_13-48-56.png"
                        alt="" 
                 ></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_year_salary (ename,year_salary)</span><br><span class="line">AS</span><br><span class="line">SELECT ename,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM t_employee;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW salvu50</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARY</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 50;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形 成一张虚拟表。</p>
<p>说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字 段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p>
<h4 id="32创建多表联合视图"><a class="markdownIt-Anchor" href="#32创建多表联合视图"></a> 3.2创建多表联合视图</h4>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empview</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_dept</span><br><span class="line">AS</span><br><span class="line">SELECT ename,dname</span><br><span class="line">FROM t_employee LEFT JOIN t_department</span><br><span class="line">ON t_employee.did = t_department.did;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW dept_sum_vu</span><br><span class="line">(name, minsal, maxsal, avgsal)</span><br><span class="line">AS</span><br><span class="line">SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)</span><br><span class="line">FROM employees e, departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">GROUP BY d.department_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>利用视图对数据进行格式化</li>
</ul>
<p>我们经常需要输出某个格式地内容，比如我们想输出员工姓名和对应部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="33基于视图创建视图"><a class="markdownIt-Anchor" href="#33基于视图创建视图"></a> 3.3基于视图创建视图</h4>
<p>当我们创建好一张视图之后，还可以在它地基础上继续创建视图。</p>
<p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_dept_ysalary</span><br><span class="line">AS</span><br><span class="line">SELECT emp_dept.ename,dname,year_salary</span><br><span class="line">FROM emp_dept INNER JOIN emp_year_salary</span><br><span class="line">ON emp_dept.ename = emp_year_salary.ename;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4查看视图"><a class="markdownIt-Anchor" href="#4查看视图"></a> 4.查看视图</h3>
<p>语法1：查看数据库地对象、视图对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语法2：查看视图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC / DESCRIBE 视图名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语法3：查看视图的属性信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line">SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p>
<p>语法4：查看视图的详细定义信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5更新视图地数据"><a class="markdownIt-Anchor" href="#5更新视图地数据"></a> 5.更新视图地数据</h3>
<h4 id="51一般情况"><a class="markdownIt-Anchor" href="#51一般情况"></a> 5.1一般情况</h4>
<p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的 数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p>
<p>举例：UPDATE操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename | tel |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789098765 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">mysql&gt; UPDATE emp_tel SET tel = &#x27;13789091234&#x27; WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1 Changed: 1 Warnings: 0</span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename | tel |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename | tel |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：DELETE操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename | tel |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; DELETE FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="52不可更新地视图"><a class="markdownIt-Anchor" href="#52不可更新地视图"></a> 5.2不可更新地视图</h4>
<p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。另外当视图定义出现如 下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li>
<li>在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作；</li>
<li>在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值；</li>
<li>在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li>
<li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE；</li>
<li>视图定义基于一个 不可更新视图 ；</li>
<li>常量视图。</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE OR REPLACE VIEW emp_dept</span><br><span class="line">-&gt; (ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">-&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname</span><br><span class="line">-&gt; FROM t_employee INNER JOIN t_department</span><br><span class="line">-&gt; ON t_employee.did = t_department.did ;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">-&gt; VALUES(&#x27;张三&#x27;,15000,&#x27;1995-01-08&#x27;,&#x27;18201587896&#x27;,</span><br><span class="line">-&gt; &#x27;zs@atguigu.com&#x27;,&#x27;2022-02-14&#x27;,&#x27;新部门&#x27;);</span><br><span class="line">#ERROR 1393 (HY000): Can not modify more than one base table through a join view</span><br><span class="line">&#x27;atguigu_chapter9.emp_dept&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新 操作。</p>
<blockquote>
<p>虽然可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的 数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</p>
</blockquote>
<h3 id="6修改-删除视图"><a class="markdownIt-Anchor" href="#6修改-删除视图"></a> 6.修改、删除视图</h3>
<h4 id="61修改视图"><a class="markdownIt-Anchor" href="#61修改视图"></a> 6.1修改视图</h4>
<p>方式1：使用CREATE OR REPLACE VIEW 子句修改视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW empvu80</span><br><span class="line">(id_number, name, sal, department_id)</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p>
</blockquote>
<p>方式2：ALTER VIEW</p>
<p>修改视图的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER VIEW 视图名称</span><br><span class="line">AS</span><br><span class="line">查询语句</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="62删除视图"><a class="markdownIt-Anchor" href="#62删除视图"></a> 6.2删除视图</h4>
<ul>
<li>删除视图只是删除视图的定义，并不会删除基表的数据。</li>
<li>删除视图的语法是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br><span class="line">DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW empvu80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这 样的视图c需要手动删除或修改，否则影响使用。</li>
</ul>
<h3 id="7总结"><a class="markdownIt-Anchor" href="#7总结"></a> 7.总结</h3>
<h4 id="71视图优点"><a class="markdownIt-Anchor" href="#71视图优点"></a> 7.1视图优点</h4>
<ul>
<li>操作简单</li>
</ul>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间 的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简 化了开发人员对数据库的操作。</p>
<ul>
<li>减少数据冗余</li>
</ul>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语 句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
<ul>
<li>数据安全</li>
</ul>
<p>MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用 户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之 间加了一层虚拟表。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-09_14-19-21.png"
                        alt="" 
                 ></p>
<p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，用户不需要查询数据表，可以直接 通过视图获取数据表中的信息。这在一定程度上保障了数据表中数据的安全性。</p>
<ul>
<li>适应灵活多变地需求</li>
</ul>
<p>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较 大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。 、</p>
<ul>
<li>能够分解复杂地查询逻辑</li>
</ul>
<p>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图 获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
<h4 id="72视图不足"><a class="markdownIt-Anchor" href="#72视图不足"></a> 7.2视图不足</h4>
<p>如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对 相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复 杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包 含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p>
<p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视 图，使系统整体达到最优。</p>
<h2 id="十五-存储过程与函数未写完"><a class="markdownIt-Anchor" href="#十五-存储过程与函数未写完"></a> 十五、存储过程与函数（未写完）</h2>
<h3 id="1存储过程概述"><a class="markdownIt-Anchor" href="#1存储过程概述"></a> 1.存储过程概述</h3>
<h4 id="11理解"><a class="markdownIt-Anchor" href="#11理解"></a> 1.1理解</h4>
<p>**含义：**存储过程的英文是  Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句 的封装。</p>
<p><strong>好处：</strong></p>
<ol>
<li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力</li>
<li>减少操作过程中的失误，提高效率</li>
<li>减少网络传输量（客户端不需要把所有的SQL语句通过网络发给服务器）</li>
<li>减少了SQL语句暴露在网上的风险，也提高了数据查询的安全性</li>
</ol>
<p>和视图、函数的对比：</p>
<p>它和视图有着同样的优点，清新、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的SQL，还可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p>
<p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过存储过程名即可。相较于函数，存储过程是没有返回值的。</p>
<h4 id="12分类"><a class="markdownIt-Anchor" href="#12分类"></a> 1.2分类</h4>
<p>存储过程的参数类型可以是IN、OUT和INOUT。根据这个 点分类如下：</p>
<ol>
<li>没有参数（无参数无返回）</li>
<li>仅仅带IN类型（有参数无返回）</li>
<li>仅仅带OUT类型（无参数有返回）</li>
<li>即带IN又带OUT（有参数有返回）</li>
<li>带INOUT（有参数有返回）</li>
</ol>
<p>注意：IN、OUT、INOUT都可以在一个存储过程中带多个。</p>
<h3 id="2创建存储过程"><a class="markdownIt-Anchor" href="#2创建存储过程"></a> 2.创建存储过程</h3>
<h4 id="21语法分析"><a class="markdownIt-Anchor" href="#21语法分析"></a> 2.1语法分析</h4>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">存储过程体</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类似于Java中的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>
<p>参数前面的符号的意思</p>
<ul>
<li>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是IN，表示输入参数。</li>
<li>OUT：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li>
<li>INOUT：当前参数既可以为输入参数，也可以为输出参数。</li>
</ul>
</li>
<li>
<p>形参类型可以是MySQL数据库中的任意类型。</p>
</li>
<li>
<p>characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
<ul>
<li>LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</li>
<li>[NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定 的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定 的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</li>
<li>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使 用SQL语句的限制。
<ul>
<li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li>
<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li>
<li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li>
<li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
</li>
<li>SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执 行当前存储过程。
<ul>
<li>DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li>
<li>INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li>
<li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li>
</ul>
</li>
<li>COMMENT ‘string’ ：注释信息，可以用来描述存储过程。</li>
</ul>
</li>
<li>
<p>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END  编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</span><br><span class="line">2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进</span><br><span class="line">行变量的声明。</span><br><span class="line">3. SET：赋值语句，用于对变量进行赋值。</span><br><span class="line">4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>需要设置新的结束标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用 DELIMITER改变存储过程的结束符。 比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定 义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。 当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">sql语句1;</span><br><span class="line">sql语句2;</span><br><span class="line">END $</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="22代码举例"><a class="markdownIt-Anchor" href="#22代码举例"></a> 2.2代码举例</h4>
<h2 id="十六-变量-流程控制与游标"><a class="markdownIt-Anchor" href="#十六-变量-流程控制与游标"></a> 十六、变量、流程控制与游标</h2>
<h3 id="1变量"><a class="markdownIt-Anchor" href="#1变量"></a> 1.变量</h3>
<p>在MySQL中数据库的存储过程中和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
<p>在MySQL数据库中，变量分为系统变量以及用户自定义变量。</p>
<h4 id="11系统变量"><a class="markdownIt-Anchor" href="#11系统变量"></a> 1.1系统变量</h4>
<h5 id="111系统变量分类"><a class="markdownIt-Anchor" href="#111系统变量分类"></a> 1.1.1系统变量分类</h5>
<p>变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。</p>
<p>系统变量分为全局系统变量（需要添加global关键字）以及会话系统变量（需要添加session关键字），有时也把全局系统变量简称为全局变量，有时也会把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在MySQL服务实例运行期间它们的值不能使用set动态修改）属于特殊的全局系统变量。</p>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变 量值的复制。如下图：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-10_10-18-46.png"
                        alt="" 
                 ></p>
<ul>
<li>全局系统变量针对于所有会话（连接）有效，但不能跨重启</li>
<li>会话系统变量仅针对当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
<p>在MySQL中有些系统变量只能是全局的，例如  max_connections 用于限制服务器的最大连接数；有些系 统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
<h5 id="112查看系统变量"><a class="markdownIt-Anchor" href="#112查看系统变量"></a> 1.1.2查看系统变量</h5>
<ul>
<li>查看所有或部分系统变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;admin_%&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看指定系统变量</li>
</ul>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变 量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在， 则标记全局系统变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>修改系统变量的值</li>
</ul>
<p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、 特征。具体方法：</p>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@global.autocommit;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br><span class="line"></span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;</span><br><span class="line"></span><br><span class="line">SET GLOBAL max_connections = 1000;</span><br><span class="line">SELECT @@global.max_connections;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="12用户变量"><a class="markdownIt-Anchor" href="#12用户变量"></a> 1.2用户变量</h4>
<h5 id="121用户变量分类"><a class="markdownIt-Anchor" href="#121用户变量分类"></a> 1.2.1用户变量分类</h5>
<p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用 范围不同，又分为 会话用户变量 和 局部变量 。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li>
<li>局部变量：只在BEGIN和END语句块中有效。局部变量只能在存储过程中使用。</li>
</ul>
<h5 id="122会话用户变量"><a class="markdownIt-Anchor" href="#122会话用户变量"></a> 1.2.2会话用户变量</h5>
<ul>
<li>变量的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看用户变量的值（查看、比较、运算等）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @用户变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @a = 1;</span><br><span class="line">SELECT @a;</span><br><span class="line"></span><br><span class="line">SELECT @num := COUNT(*) FROM employees;</span><br><span class="line">SELECT @num;</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO @avgsalary FROM employees;</span><br><span class="line">SELECT @avgsalary;</span><br><span class="line"></span><br><span class="line">SELECT @big; #查看某个未声明的变量时，将得到NULL值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="123局部变量"><a class="markdownIt-Anchor" href="#123局部变量"></a> 1.2.3局部变量</h5>
<p>定义：可以使用DECLARE语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的  BEGIN … END 中有效</p>
<p>位置： 只能放在 BEGIN … END 中，而且只能放在第一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">#为局部变量赋值</span><br><span class="line">SET 变量名1 = 值;</span><br><span class="line">SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line">#查看局部变量的值</span><br><span class="line">SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="1定义变量"><a class="markdownIt-Anchor" href="#1定义变量"></a> 1.定义变量</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE myparam INT DEFAULT 100;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="2变量赋值"><a class="markdownIt-Anchor" href="#2变量赋值"></a> 2.变量赋值</h6>
<p>方式1：一般用于赋值简单的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方式2：一般用于赋值表中的字段值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段名或表达式 INTO 变量名 FROM 表;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="3使用变量查看-比较-运算等"><a class="markdownIt-Anchor" href="#3使用变量查看-比较-运算等"></a> 3.使用变量（查看、比较、运算等）</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 局部变量名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE set_value()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE emp_name VARCHAR(25);</span><br><span class="line">    DECLARE sal DOUBLE(10,2);</span><br><span class="line">    SELECT last_name,salary INTO emp_name,sal</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE employee_id = 102;</span><br><span class="line">    SELECT emp_name,sal;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="124-对比会话用户变量与局部变量"><a class="markdownIt-Anchor" href="#124-对比会话用户变量与局部变量"></a> 1.2.4 对比会话用户变量与局部变量</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			作用域 定义位置 语法</span><br><span class="line">会话用户变量 当前会话 会话的任何地方 加@符号，不用指定类型</span><br><span class="line">局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2定义条件与处理程序"><a class="markdownIt-Anchor" href="#2定义条件与处理程序"></a> 2.定义条件与处理程序</h3>
<p>定义条件是事先定义程序执行过程中可能芋道的问题，处理程序定义了在遇到问题时应当采取的处理方式，并保证存储过程或函数遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p>
<p>说明：定义条件和处理程序存储过程、存储函数中都是支持的。</p>
<h4 id="21案例分析"><a class="markdownIt-Anchor" href="#21案例分析"></a> 2.1案例分析</h4>
<p>**案例分析：**创建 一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE UpdateDataNoCondition()</span><br><span class="line">    BEGIN</span><br><span class="line">        SET @x = 1;</span><br><span class="line">        UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">        SET @x = 2;</span><br><span class="line">        UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">        SET @x = 3;</span><br><span class="line">    END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataNoCondition();</span><br><span class="line">ERROR 1048 (23000): Column &#x27;email&#x27; cannot be null</span><br><span class="line">mysql&gt; SELECT @x;</span><br><span class="line">+------+</span><br><span class="line">| @x |</span><br><span class="line">+------+</span><br><span class="line">| 1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件 和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑， 不再向下继续执行。</p>
<h4 id="22定义条件"><a class="markdownIt-Anchor" href="#22定义条件"></a> 2.2定义条件</h4>
<p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的 错误条件 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。</p>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>错误码的说明：</p>
<ul>
<li>MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。
<ul>
<li>MySQL_error_code是数值类型错误代码。</li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
</li>
<li>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，'HY000’是sqlstate_value。</li>
<li>例如，在ERROR 1142（42000）中，1142是MySQL_error_code，'42000’是sqlstate_value。</li>
</ul>
<p>举例1：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对 应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR 1048;</span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="23定义处理程序"><a class="markdownIt-Anchor" href="#23定义处理程序"></a> 2.3定义处理程序</h4>
<p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO
<ul>
<li>CONTINUE ：表示遇到错误不处理，继续执行。</li>
<li>EXIT ：表示遇到错误马上退出。</li>
<li>UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li>错误类型（即条件）可以有如下取值：
<ul>
<li>SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码；</li>
<li>MySQL_error_code ：匹配数值类型错误代码；</li>
<li>错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。</li>
<li>SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码；</li>
<li>NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码；</li>
<li>SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
</li>
<li>处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是 像“ SET 变量 = 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。</li>
</ul>
<p>定义处理程序的几种方式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方法1：捕获sqlstate_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line">#方法2：捕获mysql_error_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line">#方法3：先定义条件，再调用</span><br><span class="line">DECLARE no_such_table CONDITION FOR 1146;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line">#方法4：使用SQLWARNING</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;</span><br><span class="line">#方法5：使用NOT FOUND</span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line">#方法6：使用SQLEXCEPTION</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="24案例解决"><a class="markdownIt-Anchor" href="#24案例解决"></a> 2.4案例解决</h4>
<p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行 CONTINUE操作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE UpdateDataNoCondition()</span><br><span class="line">    BEGIN</span><br><span class="line">        #定义处理程序</span><br><span class="line">        DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;</span><br><span class="line">        SET @x = 1;</span><br><span class="line">        UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">        SET @x = 2;</span><br><span class="line">        UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">        SET @x = 3;</span><br><span class="line">    END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataWithCondition();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">| 3 | -1 |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3流程控制"><a class="markdownIt-Anchor" href="#3流程控制"></a> 3.流程控制！！！</h3>
<p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控 制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程 就分为三大类：</p>
<ul>
<li>顺序结构：程序从上往下依次执行</li>
<li>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li>
<li>循环结构：程序满足一定条件下，重复执行一组语句</li>
</ul>
<p>针对于MySQL的流程控制语句主要有3类。注意：只能用于存储程序。</p>
<ul>
<li>条件判断语句：IF语句和CASE语句</li>
<li>循环语句：LOOP、WHILE和REPEAT语句</li>
<li>跳转语句：ITERATE和LEAVE语句</li>
</ul>
<h4 id="31分支结构之if"><a class="markdownIt-Anchor" href="#31分支结构之if"></a> 3.1分支结构之IF</h4>
<ul>
<li>IF语句的语法结构是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 表达式1 THEN 操作1</span><br><span class="line">[ELSEIF 表达式2 THEN 操作2]……</span><br><span class="line">[ELSE 操作N]</span><br><span class="line">END IF</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p>
<ul>
<li>特点：不同的表达式对应不同的操作、使用在begin end中</li>
<li></li>
</ul>
<h2 id="十七-触发器"><a class="markdownIt-Anchor" href="#十七-触发器"></a> 十七、触发器</h2>
<p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分 别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时 在库存表中添加一条库存记录。</p>
<p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操 作成为一个 原子操作 ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手 动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。</p>
<p>这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数 据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p>
<h3 id="1触发器概述"><a class="markdownIt-Anchor" href="#1触发器概述"></a> 1.触发器概述</h3>
<p>MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一 段程序。</p>
<p>触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指 用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会 自动 激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来 实现。</p>
<h3 id="2触发器的创建"><a class="markdownIt-Anchor" href="#2触发器的创建"></a> 2.触发器的创建</h3>
<h4 id="21创建触发器语法"><a class="markdownIt-Anchor" href="#21创建触发器语法"></a> 2.1创建触发器语法</h4>
<p>创建触发器的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称</span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名</span><br><span class="line">FOR EACH ROW</span><br><span class="line">触发器执行的语句块;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>表明：表示触发器监控对象。</li>
<li>BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li>
<li>INSERT|UPDATE|DELETE ：表示触发的事件。
<ul>
<li>INSERT表示插入记录时触发；</li>
<li>UPDATE表示更新记录时触发</li>
<li>DELETE表示删除记录时触发</li>
</ul>
</li>
<li>触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</li>
</ul>
<h4 id="22代码举例-2"><a class="markdownIt-Anchor" href="#22代码举例-2"></a> 2.2代码举例</h4>
<p>举例：</p>
<ul>
<li>创建数据表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_trigger (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">t_note VARCHAR(30)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE test_trigger_log (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">t_log VARCHAR(30)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向 test_trigger_log数据表中插入before_insert的日志信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER before_insert</span><br><span class="line">BEFORE INSERT ON test_trigger</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    INSERT INTO test_trigger_log (t_log)</span><br><span class="line">    VALUES(&#x27;before_insert&#x27;);</span><br><span class="line">    </span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>向test_trigger数据表中插入数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 BEFORE INSERT 触发器&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>查看test_trigger_log数据表中的数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_trigger_log;</span><br><span class="line">+----+---------------+</span><br><span class="line">| id | t_log |</span><br><span class="line">+----+---------------+</span><br><span class="line">| 1 | before_insert |</span><br><span class="line">+----+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3查看-删除触发器"><a class="markdownIt-Anchor" href="#3查看-删除触发器"></a> 3.查看、删除触发器</h3>
<h4 id="31查看触发器"><a class="markdownIt-Anchor" href="#31查看触发器"></a> 3.1查看触发器</h4>
<p>查看触发器是查看数据库中已存在的触发器的定义、状态和语法信息等。</p>
<p>方式1：查看当前数据库的所有触发器的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS\G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方式2：查看当前数据库中某个触发器的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TRIGGER 触发器名</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.TRIGGERS;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="32删除触发器"><a class="markdownIt-Anchor" href="#32删除触发器"></a> 3.2删除触发器</h4>
<p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER IF EXISTS 触发器名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4触发器的优缺点"><a class="markdownIt-Anchor" href="#4触发器的优缺点"></a> 4.触发器的优缺点</h3>
<h4 id="41优点"><a class="markdownIt-Anchor" href="#41优点"></a> 4.1优点</h4>
<h5 id="1触发器可以确保数据的完整性"><a class="markdownIt-Anchor" href="#1触发器可以确保数据的完整性"></a> 1.触发器可以确保数据的完整性</h5>
<p>假设我们用进货单头 表来确保进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-10_14-13-42.png"
                        alt="" 
                 ></p>
<p>用进货单明细表来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="https://wws-personal-note.oss-cn-beijing.aliyuncs.com/assets/Snipaste_2023-08-10_14-18-43.png"
                        alt="" 
                 ></p>
<p>每当我们录入、删除和修改 一条进货明细数据的时候， 进货单明细表里的数据就会发生变动。这个时 候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金 额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。</p>
<p>为了解决这个问题，我们就可以使用触发器，规定每当进货单明细表有数据插入、修改和删除的操作 时，自动触发 2 步操作：</p>
<ol>
<li>重新计算进货单明细表中的数量合计和金额合计；</li>
<li>用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。</li>
</ol>
<p>这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与 合计金额的值相同，数据就是一致的，不会互相矛盾。</p>
<h5 id="2触发器可以帮助我们记录操作日志"><a class="markdownIt-Anchor" href="#2触发器可以帮助我们记录操作日志"></a> 2.触发器可以帮助我们记录操作日志</h5>
<p>利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很 好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</p>
<h5 id="3触发器还可以用在操作数据前对数据进行合法性检查"><a class="markdownIt-Anchor" href="#3触发器还可以用在操作数据前对数据进行合法性检查"></a> 3.触发器还可以用在操作数据前，对数据进行合法性检查</h5>
<p>比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的 时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏…… 这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止 错误数据进入系统。</p>
<h4 id="42缺点"><a class="markdownIt-Anchor" href="#42缺点"></a> 4.2缺点</h4>
<h5 id="1-触发器最大的一个问题就是可读性差"><a class="markdownIt-Anchor" href="#1-触发器最大的一个问题就是可读性差"></a> 1. 触发器最大的一个问题就是可读性差。</h5>
<p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统 维护是非常有挑战的。</p>
<p>比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失 败。我用下面的代码演示一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update demo.membermaster set memberdeposit=20 where memberid = 2;</span><br><span class="line">ERROR 1054 (42S22): Unknown column &#x27;aa&#x27; in &#x27;field list&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果显示，系统提示错误，字段“aa”不存在。</p>
<p>这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器， 很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表 添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p>
<h5 id="2相关数据的变更可能会导致触发器出错"><a class="markdownIt-Anchor" href="#2相关数据的变更可能会导致触发器出错"></a> 2.相关数据的变更，可能会导致触发器出错。</h5>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触 发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
<h4 id="43注意点"><a class="markdownIt-Anchor" href="#43注意点"></a> 4.3注意点</h4>
<p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此 时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子 表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
<p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定 义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee） 有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，  但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器 t1。</p>
]]></content>
  </entry>
</search>
